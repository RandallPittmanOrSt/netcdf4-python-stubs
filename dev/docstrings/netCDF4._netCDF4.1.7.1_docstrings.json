{
  "netCDF4._netCDF4": "Version 1.7.1\n-------------\n\n# Introduction\n\nnetcdf4-python is a Python interface to the netCDF C library.\n\n[netCDF](http://www.unidata.ucar.edu/software/netcdf/) version 4 has many features\nnot found in earlier versions of the library and is implemented on top of\n[HDF5](http://www.hdfgroup.org/HDF5). This module can read and write\nfiles in both the new netCDF 4 and the old netCDF 3 format, and can create\nfiles that are readable by HDF5 clients. The API modelled after\n[Scientific.IO.NetCDF](http://dirac.cnrs-orleans.fr/ScientificPython/),\nand should be familiar to users of that module.\n\nMost new features of netCDF 4 are implemented, such as multiple\nunlimited dimensions, groups and data compression.  All the new\nnumeric data types (such as 64 bit and unsigned integer types) are\nimplemented. Compound (struct), variable length (vlen) and\nenumerated (enum) data types are supported, but not the opaque data type.\nMixtures of compound, vlen and enum data types (such as\ncompound types containing enums, or vlens containing compound\ntypes) are not supported.\n\n## Quick Install\n\n - the easiest way to get going is to install via `pip install netCDF4`.\n   (or if you use the [conda](http://conda.io) package manager `conda install -c conda-forge netCDF4`).\n\n## Developer Install\n\n - Clone the [github repository](http://github.com/Unidata/netcdf4-python). Make\n   sure you either clone recursively, or run `git submodule update --init` to\n   ensure all the submodules are also checked out.\n - Make sure the dependencies are satisfied (Python 3.8 or later,\n   [numpy](http://numpy.scipy.org),\n   [Cython](http://cython.org),\n   [cftime](https://github.com/Unidata/cftime),\n   [setuptools](https://pypi.python.org/pypi/setuptools),\n   the [HDF5 C library](https://www.hdfgroup.org/solutions/hdf5/),\n   and the [netCDF C library](https://www.unidata.ucar.edu/software/netcdf/)).\n   For MPI parallel IO support, an MPI-enabled versions of the netcdf library\n   is required, as is [mpi4py](http://mpi4py.scipy.org).\n   Parallel IO further depends on the existence of MPI-enabled HDF5 or the\n   [PnetCDF](https://parallel-netcdf.github.io/) library.\n - By default, the utility `nc-config` (installed with netcdf-c)\n   will be run used to determine where all the dependencies live.\n - If `nc-config` is not in your default `PATH`, you can set the `NETCDF4_DIR`\n   environment variable and `setup.py` will look in `$NETCDF4_DIR/bin`.\n   You can also use the file `setup.cfg` to set the path to `nc-config`, or\n   enter the paths to the libraries and include files manually. Just  edit the `setup.cfg` file\n   in a text editor and follow the instructions in the comments.\n   To disable the use of `nc-config`, set the env var `USE_NCCONFIG` to 0.\n   To disable the use of `setup.cfg`, set `USE_SETUPCFG` to 0.\n   As a last resort, the library and include paths can be set via environment variables.\n   If you go this route, set `USE_NCCONFIG` and `USE_SETUPCFG` to 0, and specify\n   `NETCDF4_LIBDIR`, `NETCDF4_INCDIR`, `HDF5_LIBDIR` and `HDF5_INCDIR`.\n   If the dependencies are not found\n   in any of the paths specified by environment variables, then standard locations\n   (such as `/usr` and `/usr/local`) are searched.\n - if the env var `NETCDF_PLUGIN_DIR` is set to point to the location of the netcdf-c compression\n   plugins built by netcdf >= 4.9.0, they will be installed inside the package.  In this\n   case `HDF5_PLUGIN_PATH` will be set to the package installation path on import,\n   so the extra compression algorithms available in netcdf-c >= 4.9.0 will automatically\n   be available.  Otherwise, the user will have to set `HDF5_PLUGIN_PATH` explicitly\n   to have access to the extra compression plugins.\n - run `pip install -v .` (as root if necessary)\n - run the tests in the 'test' directory by running `python run_all.py`.\n\n# Tutorial\n\n- [Creating/Opening/Closing a netCDF file](#creatingopeningclosing-a-netcdf-file)\n- [Groups in a netCDF file](#groups-in-a-netcdf-file)\n- [Dimensions in a netCDF file](#dimensions-in-a-netcdf-file)\n- [Variables in a netCDF file](#variables-in-a-netcdf-file)\n- [Attributes in a netCDF file](#attributes-in-a-netcdf-file)\n- [Dealing with time coordinates](#dealing-with-time-coordinates)\n- [Writing data to and retrieving data from a netCDF variable](#writing-data-to-and-retrieving-data-from-a-netcdf-variable)\n- [Reading data from a multi-file netCDF dataset](#reading-data-from-a-multi-file-netcdf-dataset)\n- [Efficient compression of netCDF variables](#efficient-compression-of-netcdf-variables)\n- [Beyond homogeneous arrays of a fixed type - compound data types](#beyond-homogeneous-arrays-of-a-fixed-type-compound-data-types)\n- [Variable-length (vlen) data types](#variable-length-vlen-data-types)\n- [Enum data type](#enum-data-type)\n- [Parallel IO](#parallel-io)\n- [Dealing with strings](#dealing-with-strings)\n- [In-memory (diskless) Datasets](#in-memory-diskless-datasets)\n\nAll of the code in this tutorial is available in `examples/tutorial.py`, except\nthe parallel IO example, which is in `examples/mpi_example.py`.\nUnit tests are in the `test` directory.\n\n## Creating/Opening/Closing a netCDF file\n\nTo create a netCDF file from python, you simply call the `Dataset`\nconstructor. This is also the method used to open an existing netCDF\nfile.  If the file is open for write access (`mode='w', 'r+'` or `'a'`), you may\nwrite any type of data including new dimensions, groups, variables and\nattributes.  netCDF files come in five flavors (`NETCDF3_CLASSIC,\nNETCDF3_64BIT_OFFSET, NETCDF3_64BIT_DATA, NETCDF4_CLASSIC`, and `NETCDF4`).\n`NETCDF3_CLASSIC` was the original netcdf binary format, and was limited\nto file sizes less than 2 Gb. `NETCDF3_64BIT_OFFSET` was introduced\nin version 3.6.0 of the library, and extended the original binary format\nto allow for file sizes greater than 2 Gb.\n`NETCDF3_64BIT_DATA` is a new format that requires version 4.4.0 of\nthe C library - it extends the `NETCDF3_64BIT_OFFSET` binary format to\nallow for unsigned/64 bit integer data types and 64-bit dimension sizes.\n`NETCDF3_64BIT` is an alias for `NETCDF3_64BIT_OFFSET`.\n`NETCDF4_CLASSIC` files use the version 4 disk format (HDF5), but omits features\nnot found in the version 3 API. They can be read by netCDF 3 clients\nonly if they have been relinked against the netCDF 4 library. They can\nalso be read by HDF5 clients. `NETCDF4` files use the version 4 disk\nformat (HDF5) and use the new features of the version 4 API.  The\nnetCDF4 module can read and write files in any of these formats. When\ncreating a new file, the format may be specified using the `format`\nkeyword in the `Dataset` constructor.  The default format is\n`NETCDF4`. To see how a given file is formatted, you can examine the\n`data_model` attribute.  Closing the netCDF file is\naccomplished via the `Dataset.close` method of the `Dataset`\ninstance.\n\nHere's an example:\n\n```python\n>>> from netCDF4 import Dataset\n>>> rootgrp = Dataset(\"test.nc\", \"w\", format=\"NETCDF4\")\n>>> print(rootgrp.data_model)\nNETCDF4\n>>> rootgrp.close()\n```\n\nRemote [OPeNDAP](http://opendap.org)-hosted datasets can be accessed for\nreading over http if a URL is provided to the `Dataset` constructor instead of a\nfilename.  However, this requires that the netCDF library be built with\nOPenDAP support, via the `--enable-dap` configure option (added in\nversion 4.0.1).\n\n\n## Groups in a netCDF file\n\nnetCDF version 4 added support for organizing data in hierarchical\ngroups, which are analogous to directories in a filesystem. Groups serve\nas containers for variables, dimensions and attributes, as well as other\ngroups.  A `Dataset` creates a special group, called\nthe 'root group', which is similar to the root directory in a unix\nfilesystem.  To create `Group` instances, use the\n`Dataset.createGroup` method of a `Dataset` or `Group`\ninstance. `Dataset.createGroup` takes a single argument, a\npython string containing the name of the new group. The new `Group`\ninstances contained within the root group can be accessed by name using\nthe `groups` dictionary attribute of the `Dataset` instance.  Only\n`NETCDF4` formatted files support Groups, if you try to create a Group\nin a netCDF 3 file you will get an error message.\n\n```python\n>>> rootgrp = Dataset(\"test.nc\", \"a\")\n>>> fcstgrp = rootgrp.createGroup(\"forecasts\")\n>>> analgrp = rootgrp.createGroup(\"analyses\")\n>>> print(rootgrp.groups)\n{'forecasts': <class 'netCDF4._netCDF4.Group'>\ngroup /forecasts:\n    dimensions(sizes):\n    variables(dimensions):\n    groups: , 'analyses': <class 'netCDF4._netCDF4.Group'>\ngroup /analyses:\n    dimensions(sizes):\n    variables(dimensions):\n    groups: }\n>>>\n```\n\nGroups can exist within groups in a `Dataset`, just as directories\nexist within directories in a unix filesystem. Each `Group` instance\nhas a `groups` attribute dictionary containing all of the group\ninstances contained within that group. Each `Group` instance also has a\n`path` attribute that contains a simulated unix directory path to\nthat group.  To simplify the creation of nested groups, you can\nuse a unix-like path as an argument to `Dataset.createGroup`.\n\n```python\n>>> fcstgrp1 = rootgrp.createGroup(\"/forecasts/model1\")\n>>> fcstgrp2 = rootgrp.createGroup(\"/forecasts/model2\")\n```\n\nIf any of the intermediate elements of the path do not exist, they are created,\njust as with the unix command `'mkdir -p'`. If you try to create a group\nthat already exists, no error will be raised, and the existing group will be\nreturned.\n\nHere's an example that shows how to navigate all the groups in a\n`Dataset`. The function `walktree` is a Python generator that is used\nto walk the directory tree. Note that printing the `Dataset` or `Group`\nobject yields summary information about it's contents.\n\n```python\n>>> def walktree(top):\n...     yield top.groups.values()\n...     for value in top.groups.values():\n...         yield from walktree(value)\n>>> print(rootgrp)\n<class 'netCDF4._netCDF4.Dataset'>\nroot group (NETCDF4 data model, file format HDF5):\n    dimensions(sizes):\n    variables(dimensions):\n    groups: forecasts, analyses\n>>> for children in walktree(rootgrp):\n...     for child in children:\n...         print(child)\n<class 'netCDF4._netCDF4.Group'>\ngroup /forecasts:\n    dimensions(sizes):\n    variables(dimensions):\n    groups: model1, model2\n<class 'netCDF4._netCDF4.Group'>\ngroup /analyses:\n    dimensions(sizes):\n    variables(dimensions):\n    groups:\n<class 'netCDF4._netCDF4.Group'>\ngroup /forecasts/model1:\n    dimensions(sizes):\n    variables(dimensions):\n    groups:\n<class 'netCDF4._netCDF4.Group'>\ngroup /forecasts/model2:\n    dimensions(sizes):\n    variables(dimensions):\n    groups:\n```\n\n## Dimensions in a netCDF file\n\nnetCDF defines the sizes of all variables in terms of dimensions, so\nbefore any variables can be created the dimensions they use must be\ncreated first. A special case, not often used in practice, is that of a\nscalar variable, which has no dimensions. A dimension is created using\nthe `Dataset.createDimension` method of a `Dataset`\nor `Group` instance. A Python string is used to set the name of the\ndimension, and an integer value is used to set the size. To create an\nunlimited dimension (a dimension that can be appended to), the size\nvalue is set to `None` or 0. In this example, there both the `time` and\n`level` dimensions are unlimited.  Having more than one unlimited\ndimension is a new netCDF 4 feature, in netCDF 3 files there may be only\none, and it must be the first (leftmost) dimension of the variable.\n\n```python\n>>> level = rootgrp.createDimension(\"level\", None)\n>>> time = rootgrp.createDimension(\"time\", None)\n>>> lat = rootgrp.createDimension(\"lat\", 73)\n>>> lon = rootgrp.createDimension(\"lon\", 144)\n```\n\n\nAll of the `Dimension` instances are stored in a python dictionary.\n\n```python\n>>> print(rootgrp.dimensions)\n{'level': <class 'netCDF4._netCDF4.Dimension'> (unlimited): name = 'level', size = 0, 'time': <class 'netCDF4._netCDF4.Dimension'> (unlimited): name = 'time', size = 0, 'lat': <class 'netCDF4._netCDF4.Dimension'>: name = 'lat', size = 73, 'lon': <class 'netCDF4._netCDF4.Dimension'>: name = 'lon', size = 144}\n```\n\nUsing the python `len` function with a `Dimension` instance returns\ncurrent size of that dimension.\n`Dimension.isunlimited` method of a `Dimension` instance\nbe used to determine if the dimensions is unlimited, or appendable.\n\n```python\n>>> print(len(lon))\n144\n>>> print(lon.isunlimited())\nFalse\n>>> print(time.isunlimited())\nTrue\n```\n\nPrinting the `Dimension` object\nprovides useful summary info, including the name and length of the dimension,\nand whether it is unlimited.\n\n```python\n>>> for dimobj in rootgrp.dimensions.values():\n...     print(dimobj)\n<class 'netCDF4._netCDF4.Dimension'> (unlimited): name = 'level', size = 0\n<class 'netCDF4._netCDF4.Dimension'> (unlimited): name = 'time', size = 0\n<class 'netCDF4._netCDF4.Dimension'>: name = 'lat', size = 73\n<class 'netCDF4._netCDF4.Dimension'>: name = 'lon', size = 144\n```\n\n`Dimension` names can be changed using the\n`Datatset.renameDimension` method of a `Dataset` or\n`Group` instance.\n\n## Variables in a netCDF file\n\nnetCDF variables behave much like python multidimensional array objects\nsupplied by the [numpy module](http://numpy.scipy.org). However,\nunlike numpy arrays, netCDF4 variables can be appended to along one or\nmore 'unlimited' dimensions. To create a netCDF variable, use the\n`Dataset.createVariable` method of a `Dataset` or\n`Group` instance. The `Dataset.createVariable`j method\nhas two mandatory arguments, the variable name (a Python string), and\nthe variable datatype. The variable's dimensions are given by a tuple\ncontaining the dimension names (defined previously with\n`Dataset.createDimension`). To create a scalar\nvariable, simply leave out the dimensions keyword. The variable\nprimitive datatypes correspond to the dtype attribute of a numpy array.\nYou can specify the datatype as a numpy dtype object, or anything that\ncan be converted to a numpy dtype object.  Valid datatype specifiers\ninclude: `'f4'` (32-bit floating point), `'f8'` (64-bit floating\npoint), `'i4'` (32-bit signed integer), `'i2'` (16-bit signed\ninteger), `'i8'` (64-bit signed integer), `'i1'` (8-bit signed\ninteger), `'u1'` (8-bit unsigned integer), `'u2'` (16-bit unsigned\ninteger), `'u4'` (32-bit unsigned integer), `'u8'` (64-bit unsigned\ninteger), or `'S1'` (single-character string).  The old Numeric\nsingle-character typecodes (`'f'`,`'d'`,`'h'`,\n`'s'`,`'b'`,`'B'`,`'c'`,`'i'`,`'l'`), corresponding to\n(`'f4'`,`'f8'`,`'i2'`,`'i2'`,`'i1'`,`'i1'`,`'S1'`,`'i4'`,`'i4'`),\nwill also work. The unsigned integer types and the 64-bit integer type\ncan only be used if the file format is `NETCDF4`.\n\nThe dimensions themselves are usually also defined as variables, called\ncoordinate variables. The `Dataset.createVariable`\nmethod returns an instance of the `Variable` class whose methods can be\nused later to access and set variable data and attributes.\n\n```python\n>>> times = rootgrp.createVariable(\"time\",\"f8\",(\"time\",))\n>>> levels = rootgrp.createVariable(\"level\",\"i4\",(\"level\",))\n>>> latitudes = rootgrp.createVariable(\"lat\",\"f4\",(\"lat\",))\n>>> longitudes = rootgrp.createVariable(\"lon\",\"f4\",(\"lon\",))\n>>> # two dimensions unlimited\n>>> temp = rootgrp.createVariable(\"temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",))\n>>> temp.units = \"K\"\n```\n\nTo get summary info on a `Variable` instance in an interactive session,\njust print it.\n\n```python\n>>> print(temp)\n<class 'netCDF4._netCDF4.Variable'>\nfloat32 temp(time, level, lat, lon)\n    units: K\nunlimited dimensions: time, level\ncurrent shape = (0, 0, 73, 144)\nfilling on, default _FillValue of 9.969209968386869e+36 used\n```\n\nYou can use a path to create a Variable inside a hierarchy of groups.\n\n```python\n>>> ftemp = rootgrp.createVariable(\"/forecasts/model1/temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",))\n```\n\nIf the intermediate groups do not yet exist, they will be created.\n\nYou can also query a `Dataset` or `Group` instance directly to obtain `Group` or\n`Variable` instances using paths.\n\n```python\n>>> print(rootgrp[\"/forecasts/model1\"])  # a Group instance\n<class 'netCDF4._netCDF4.Group'>\ngroup /forecasts/model1:\n    dimensions(sizes):\n    variables(dimensions): float32 temp(time,level,lat,lon)\n    groups:\n>>> print(rootgrp[\"/forecasts/model1/temp\"])  # a Variable instance\n<class 'netCDF4._netCDF4.Variable'>\nfloat32 temp(time, level, lat, lon)\npath = /forecasts/model1\nunlimited dimensions: time, level\ncurrent shape = (0, 0, 73, 144)\nfilling on, default _FillValue of 9.969209968386869e+36 used\n```\n\n\nAll of the variables in the `Dataset` or `Group` are stored in a\nPython dictionary, in the same way as the dimensions:\n\n```python\n>>> print(rootgrp.variables)\n{'time': <class 'netCDF4._netCDF4.Variable'>\nfloat64 time(time)\nunlimited dimensions: time\ncurrent shape = (0,)\nfilling on, default _FillValue of 9.969209968386869e+36 used, 'level': <class 'netCDF4._netCDF4.Variable'>\nint32 level(level)\nunlimited dimensions: level\ncurrent shape = (0,)\nfilling on, default _FillValue of -2147483647 used, 'lat': <class 'netCDF4._netCDF4.Variable'>\nfloat32 lat(lat)\nunlimited dimensions:\ncurrent shape = (73,)\nfilling on, default _FillValue of 9.969209968386869e+36 used, 'lon': <class 'netCDF4._netCDF4.Variable'>\nfloat32 lon(lon)\nunlimited dimensions:\ncurrent shape = (144,)\nfilling on, default _FillValue of 9.969209968386869e+36 used, 'temp': <class 'netCDF4._netCDF4.Variable'>\nfloat32 temp(time, level, lat, lon)\n    units: K\nunlimited dimensions: time, level\ncurrent shape = (0, 0, 73, 144)\nfilling on, default _FillValue of 9.969209968386869e+36 used}\n```\n\n`Variable` names can be changed using the\n`Dataset.renameVariable` method of a `Dataset`\ninstance.\n\nVariables can be sliced similar to numpy arrays, but there are some differences.  See\n[Writing data to and retrieving data from a netCDF variable](#writing-data-to-and-retrieving-data-from-a-netcdf-variable) for more details.\n\n\n## Attributes in a netCDF file\n\nThere are two types of attributes in a netCDF file, global and variable.\nGlobal attributes provide information about a group, or the entire\ndataset, as a whole. `Variable` attributes provide information about\none of the variables in a group. Global attributes are set by assigning\nvalues to `Dataset` or `Group` instance variables. `Variable`\nattributes are set by assigning values to `Variable` instances\nvariables. Attributes can be strings, numbers or sequences. Returning to\nour example,\n\n```python\n>>> import time\n>>> rootgrp.description = \"bogus example script\"\n>>> rootgrp.history = \"Created \" + time.ctime(time.time())\n>>> rootgrp.source = \"netCDF4 python module tutorial\"\n>>> latitudes.units = \"degrees north\"\n>>> longitudes.units = \"degrees east\"\n>>> levels.units = \"hPa\"\n>>> temp.units = \"K\"\n>>> times.units = \"hours since 0001-01-01 00:00:00.0\"\n>>> times.calendar = \"gregorian\"\n```\n\nThe `Dataset.ncattrs` method of a `Dataset`, `Group` or\n`Variable` instance can be used to retrieve the names of all the netCDF\nattributes. This method is provided as a convenience, since using the\nbuilt-in `dir` Python function will return a bunch of private methods\nand attributes that cannot (or should not) be modified by the user.\n\n```python\n>>> for name in rootgrp.ncattrs():\n...     print(\"Global attr {} = {}\".format(name, getattr(rootgrp, name)))\nGlobal attr description = bogus example script\nGlobal attr history = Created Mon Jul  8 14:19:41 2019\nGlobal attr source = netCDF4 python module tutorial\n```\n\nThe `__dict__` attribute of a `Dataset`, `Group` or `Variable`\ninstance provides all the netCDF attribute name/value pairs in a python\ndictionary:\n\n```python\n>>> print(rootgrp.__dict__)\n{'description': 'bogus example script', 'history': 'Created Mon Jul  8 14:19:41 2019', 'source': 'netCDF4 python module tutorial'}\n```\n\nAttributes can be deleted from a netCDF `Dataset`, `Group` or\n`Variable` using the python `del` statement (i.e. `del grp.foo`\nremoves the attribute `foo` the the group `grp`).\n\n## Writing data to and retrieving data from a netCDF variable\n\nNow that you have a netCDF `Variable` instance, how do you put data\ninto it? You can just treat it like an array and assign data to a slice.\n\n```python\n>>> import numpy as np\n>>> lats =  np.arange(-90,91,2.5)\n>>> lons =  np.arange(-180,180,2.5)\n>>> latitudes[:] = lats\n>>> longitudes[:] = lons\n>>> print(\"latitudes =\\n{}\".format(latitudes[:]))\nlatitudes =\n[-90.  -87.5 -85.  -82.5 -80.  -77.5 -75.  -72.5 -70.  -67.5 -65.  -62.5\n -60.  -57.5 -55.  -52.5 -50.  -47.5 -45.  -42.5 -40.  -37.5 -35.  -32.5\n -30.  -27.5 -25.  -22.5 -20.  -17.5 -15.  -12.5 -10.   -7.5  -5.   -2.5\n   0.    2.5   5.    7.5  10.   12.5  15.   17.5  20.   22.5  25.   27.5\n  30.   32.5  35.   37.5  40.   42.5  45.   47.5  50.   52.5  55.   57.5\n  60.   62.5  65.   67.5  70.   72.5  75.   77.5  80.   82.5  85.   87.5\n  90. ]\n```\n\nUnlike NumPy's array objects, netCDF `Variable`\nobjects with unlimited dimensions will grow along those dimensions if you\nassign data outside the currently defined range of indices.\n\n```python\n>>> # append along two unlimited dimensions by assigning to slice.\n>>> nlats = len(rootgrp.dimensions[\"lat\"])\n>>> nlons = len(rootgrp.dimensions[\"lon\"])\n>>> print(\"temp shape before adding data = {}\".format(temp.shape))\ntemp shape before adding data = (0, 0, 73, 144)\n>>>\n>>> from numpy.random import uniform\n>>> temp[0:5, 0:10, :, :] = uniform(size=(5, 10, nlats, nlons))\n>>> print(\"temp shape after adding data = {}\".format(temp.shape))\ntemp shape after adding data = (5, 10, 73, 144)\n>>>\n>>> # levels have grown, but no values yet assigned.\n>>> print(\"levels shape after adding pressure data = {}\".format(levels.shape))\nlevels shape after adding pressure data = (10,)\n```\n\nNote that the size of the levels variable grows when data is appended\nalong the `level` dimension of the variable `temp`, even though no\ndata has yet been assigned to levels.\n\n```python\n>>> # now, assign data to levels dimension variable.\n>>> levels[:] =  [1000.,850.,700.,500.,300.,250.,200.,150.,100.,50.]\n```\n\nHowever, that there are some differences between NumPy and netCDF\nvariable slicing rules. Slices behave as usual, being specified as a\n`start:stop:step` triplet. Using a scalar integer index `i` takes the ith\nelement and reduces the rank of the output array by one. Boolean array and\ninteger sequence indexing behaves differently for netCDF variables\nthan for numpy arrays.  Only 1-d boolean arrays and integer sequences are\nallowed, and these indices work independently along each dimension (similar\nto the way vector subscripts work in fortran).  This means that\n\n```python\n>>> temp[0, 0, [0,1,2,3], [0,1,2,3]].shape\n(4, 4)\n```\n\nreturns an array of shape (4,4) when slicing a netCDF variable, but for a\nnumpy array it returns an array of shape (4,).\nSimilarly, a netCDF variable of shape `(2,3,4,5)` indexed\nwith `[0, array([True, False, True]), array([False, True, True, True]), :]`\nwould return a `(2, 3, 5)` array. In NumPy, this would raise an error since\nit would be equivalent to `[0, [0,1], [1,2,3], :]`. When slicing with integer\nsequences, the indices ***need not be sorted*** and ***may contain\nduplicates*** (both of these are new features in version 1.2.1).\nWhile this behaviour may cause some confusion for those used to NumPy's 'fancy indexing' rules,\nit provides a very powerful way to extract data from multidimensional netCDF\nvariables by using logical operations on the dimension arrays to create slices.\n\nFor example,\n\n```python\n>>> tempdat = temp[::2, [1,3,6], lats>0, lons>0]\n```\n\nwill extract time indices 0,2 and 4, pressure levels\n850, 500 and 200 hPa, all Northern Hemisphere latitudes and Eastern\nHemisphere longitudes, resulting in a numpy array of shape  (3, 3, 36, 71).\n\n```python\n>>> print(\"shape of fancy temp slice = {}\".format(tempdat.shape))\nshape of fancy temp slice = (3, 3, 36, 71)\n```\n\n***Special note for scalar variables***: To extract data from a scalar variable\n`v` with no associated dimensions, use `numpy.asarray(v)` or `v[...]`.\nThe result will be a numpy scalar array.\n\nBy default, netcdf4-python returns numpy masked arrays with values equal to the\n`missing_value` or `_FillValue` variable attributes masked for primitive and\nenum data types.\nThe `Dataset.set_auto_mask` `Dataset` and `Variable` methods\ncan be used to disable this feature so that\nnumpy arrays are always returned, with the missing values included. Prior to\nversion 1.4.0 the default behavior was to only return masked arrays when the\nrequested slice contained missing values.  This behavior can be recovered\nusing the `Dataset.set_always_mask` method. If a masked array is\nwritten to a netCDF variable, the masked elements are filled with the\nvalue specified by the `missing_value` attribute.  If the variable has\nno `missing_value`, the `_FillValue` is used instead.\n\n## Dealing with time coordinates\n\nTime coordinate values pose a special challenge to netCDF users.  Most\nmetadata standards (such as CF) specify that time should be\nmeasure relative to a fixed date using a certain calendar, with units\nspecified like `hours since YY-MM-DD hh:mm:ss`.  These units can be\nawkward to deal with, without a utility to convert the values to and\nfrom calendar dates.  The functions [num2date](https://unidata.github.io/cftime/api.html)\nand [date2num](https://unidata.github.io/cftime/api.html) are\nprovided by [cftime](https://unidata.github.io/cftime) to do just that.\nHere's an example of how they can be used:\n\n```python\n>>> # fill in times.\n>>> from datetime import datetime, timedelta\n>>> from cftime import num2date, date2num\n>>> dates = [datetime(2001,3,1)+n*timedelta(hours=12) for n in range(temp.shape[0])]\n>>> times[:] = date2num(dates,units=times.units,calendar=times.calendar)\n>>> print(\"time values (in units {}):\\n{}\".format(times.units, times[:]))\ntime values (in units hours since 0001-01-01 00:00:00.0):\n[17533104. 17533116. 17533128. 17533140. 17533152.]\n>>> dates = num2date(times[:],units=times.units,calendar=times.calendar)\n>>> print(\"dates corresponding to time values:\\n{}\".format(dates))\n [cftime.DatetimeGregorian(2001, 3, 1, 0, 0, 0, 0, has_year_zero=False)\n  cftime.DatetimeGregorian(2001, 3, 1, 12, 0, 0, 0, has_year_zero=False)\n  cftime.DatetimeGregorian(2001, 3, 2, 0, 0, 0, 0, has_year_zero=False)\n  cftime.DatetimeGregorian(2001, 3, 2, 12, 0, 0, 0, has_year_zero=False)\n  cftime.DatetimeGregorian(2001, 3, 3, 0, 0, 0, 0, has_year_zero=False)]\n```\n\n`num2date` converts numeric values of time in the specified `units`\nand `calendar` to datetime objects, and `date2num` does the reverse.\nAll the calendars currently defined in the\n[CF metadata convention](http://cfconventions.org) are supported.\nA function called `date2index` is also provided which returns the indices\nof a netCDF time variable corresponding to a sequence of datetime instances.\n\n\n## Reading data from a multi-file netCDF dataset\n\nIf you want to read data from a variable that spans multiple netCDF files,\nyou can use the `MFDataset` class to read the data as if it were\ncontained in a single file. Instead of using a single filename to create\na `Dataset` instance, create a `MFDataset` instance with either a list\nof filenames, or a string with a wildcard (which is then converted to\na sorted list of files using the python glob module).\nVariables in the list of files that share the same unlimited\ndimension are aggregated together, and can be sliced across multiple\nfiles.  To illustrate this, let's first create a bunch of netCDF files with\nthe same variable (with the same unlimited dimension).  The files\nmust in be in `NETCDF3_64BIT_OFFSET`, `NETCDF3_64BIT_DATA`, `NETCDF3_CLASSIC` or\n`NETCDF4_CLASSIC` format (`NETCDF4` formatted multi-file\ndatasets are not supported).\n\n```python\n>>> for nf in range(10):\n...     with Dataset(\"mftest%s.nc\" % nf, \"w\", format=\"NETCDF4_CLASSIC\") as f:\n...         _ = f.createDimension(\"x\",None)\n...         x = f.createVariable(\"x\",\"i\",(\"x\",))\n...         x[0:10] = np.arange(nf*10,10*(nf+1))\n```\n\nNow read all the files back in at once with `MFDataset`\n\n```python\n>>> from netCDF4 import MFDataset\n>>> f = MFDataset(\"mftest*nc\")\n>>> print(f.variables[\"x\"][:])\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\n 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47\n 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71\n 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95\n 96 97 98 99]\n```\n\nNote that `MFDataset` can only be used to read, not write, multi-file\ndatasets.\n\n## Efficient compression of netCDF variables\n\nData stored in netCDF `Variable` objects can be compressed and\ndecompressed on the fly. The compression algorithm used is determined\nby the `compression` keyword argument to the `Dataset.createVariable` method.\n`zlib` compression is always available, `szip` is available if the linked HDF5\nlibrary supports it, and `zstd`, `bzip2`, `blosc_lz`,`blosc_lz4`,`blosc_lz4hc`,\n`blosc_zlib` and `blosc_zstd` are available via optional external plugins.\nThe `complevel` keyword regulates the\nspeed and efficiency of the compression for `zlib`, `bzip` and `zstd` (1 being fastest, but lowest\ncompression ratio, 9 being slowest but best compression ratio). The\ndefault value of `complevel` is 4. Setting `shuffle=False` will turn\noff the HDF5 shuffle filter, which de-interlaces a block of data before\n`zlib` compression by reordering the bytes.  The shuffle filter can\nsignificantly improve compression ratios, and is on by default if `compression=zlib`.  Setting\n`fletcher32` keyword argument to\n`Dataset.createVariable` to `True` (it's `False` by\ndefault) enables the Fletcher32 checksum algorithm for error detection.\nIt's also possible to set the HDF5 chunking parameters and endian-ness\nof the binary data stored in the HDF5 file with the `chunksizes`\nand `endian` keyword arguments to\n`Dataset.createVariable`.  These keyword arguments only\nare relevant for `NETCDF4` and `NETCDF4_CLASSIC` files (where the\nunderlying file format is HDF5) and are silently ignored if the file\nformat is `NETCDF3_CLASSIC`, `NETCDF3_64BIT_OFFSET` or `NETCDF3_64BIT_DATA`.\nIf the HDF5 library is built with szip support, compression=`szip` can also\nbe used (in conjunction with the `szip_coding` and `szip_pixels_per_block` keyword\narguments).\n\nIf your data only has a certain number of digits of precision (say for\nexample, it is temperature data that was measured with a precision of\n0.1 degrees), you can dramatically improve compression by\nquantizing (or truncating) the data. There are two methods supplied for\ndoing this.  You can use the `least_significant_digit`\nkeyword argument to `Dataset.createVariable` to specify\nthe power of ten of the smallest decimal place in\nthe data that is a reliable value. For example if the data has a\nprecision of 0.1, then setting `least_significant_digit=1` will cause\ndata the data to be quantized using `numpy.around(scale*data)/scale`, where\nscale = 2**bits, and bits is determined so that a precision of 0.1 is\nretained (in this case bits=4).  This is done at the python level and is\nnot a part of the underlying C library.  Starting with netcdf-c version 4.9.0,\na quantization capability is provided in the library.  This can be\nused via the `significant_digits` `Dataset.createVariable` kwarg (new in\nversion 1.6.0).\nThe interpretation of `significant_digits` is different than `least_signficant_digit`\nin that it specifies the absolute number of significant digits independent\nof the magnitude of the variable (the floating point exponent).\nEither of these approaches makes the compression\n'lossy' instead of 'lossless', that is some precision in the data is\nsacrificed for the sake of disk space.\n\nIn our example, try replacing the line\n\n```python\n>>> temp = rootgrp.createVariable(\"temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",))\n```\n\nwith\n\n```python\n>>> temp = rootgrp.createVariable(\"temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",),compression='zlib')\n```\n\nand then\n\n```python\n>>> temp = rootgrp.createVariable(\"temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",),compression='zlib',least_significant_digit=3)\n```\n\nor with netcdf-c >= 4.9.0\n\n```python\n>>> temp = rootgrp.createVariable(\"temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",),compression='zlib',significant_digits=4)\n```\n\nand see how much smaller the resulting files are.\n\n## Beyond homogeneous arrays of a fixed type - compound data types\n\nCompound data types map directly to numpy structured (a.k.a 'record')\narrays.  Structured arrays are akin to C structs, or derived types\nin Fortran. They allow for the construction of table-like structures\ncomposed of combinations of other data types, including other\ncompound types. Compound types might be useful for representing multiple\nparameter values at each point on a grid, or at each time and space\nlocation for scattered (point) data. You can then access all the\ninformation for a point by reading one variable, instead of reading\ndifferent parameters from different variables.  Compound data types\nare created from the corresponding numpy data type using the\n`Dataset.createCompoundType` method of a `Dataset` or `Group` instance.\nSince there is no native complex data type in netcdf (but see\n[Support for complex numbers](#support-for-complex-numbers)), compound\ntypes are handy for storing numpy complex arrays. Here's an example:\n\n```python\n>>> f = Dataset(\"complex.nc\",\"w\")\n>>> size = 3 # length of 1-d complex array\n>>> # create sample complex data.\n>>> datac = np.exp(1j*(1.+np.linspace(0, np.pi, size)))\n>>> # create complex128 compound data type.\n>>> complex128 = np.dtype([(\"real\",np.float64),(\"imag\",np.float64)])\n>>> complex128_t = f.createCompoundType(complex128,\"complex128\")\n>>> # create a variable with this data type, write some data to it.\n>>> x_dim = f.createDimension(\"x_dim\",None)\n>>> v = f.createVariable(\"cmplx_var\",complex128_t,\"x_dim\")\n>>> data = np.empty(size,complex128) # numpy structured array\n>>> data[\"real\"] = datac.real; data[\"imag\"] = datac.imag\n>>> v[:] = data # write numpy structured array to netcdf compound var\n>>> # close and reopen the file, check the contents.\n>>> f.close(); f = Dataset(\"complex.nc\")\n>>> v = f.variables[\"cmplx_var\"]\n>>> datain = v[:] # read in all the data into a numpy structured array\n>>> # create an empty numpy complex array\n>>> datac2 = np.empty(datain.shape,np.complex128)\n>>> # .. fill it with contents of structured array.\n>>> datac2.real = datain[\"real\"]; datac2.imag = datain[\"imag\"]\n>>> print('{}: {}'.format(datac.dtype, datac)) # original data\ncomplex128: [ 0.54030231+0.84147098j -0.84147098+0.54030231j -0.54030231-0.84147098j]\n>>>\n>>> print('{}: {}'.format(datac2.dtype, datac2)) # data from file\ncomplex128: [ 0.54030231+0.84147098j -0.84147098+0.54030231j -0.54030231-0.84147098j]\n```\n\nCompound types can be nested, but you must create the 'inner'\nones first. All possible numpy structured arrays cannot be\nrepresented as Compound variables - an error message will be\nraise if you try to create one that is not supported.\nAll of the compound types defined for a `Dataset` or `Group` are stored\nin a Python dictionary, just like variables and dimensions. As always, printing\nobjects gives useful summary information in an interactive session:\n\n```python\n>>> print(f)\n<class 'netCDF4._netCDF4.Dataset'>\nroot group (NETCDF4 data model, file format HDF5):\n    dimensions(sizes): x_dim(3)\n    variables(dimensions): {'names':['real','imag'], 'formats':['<f8','<f8'], 'offsets':[0,8], 'itemsize':16, 'aligned':True} cmplx_var(x_dim)\n    groups:\n>>> print(f.variables[\"cmplx_var\"])\n<class 'netCDF4._netCDF4.Variable'>\ncompound cmplx_var(x_dim)\ncompound data type: {'names':['real','imag'], 'formats':['<f8','<f8'], 'offsets':[0,8], 'itemsize':16, 'aligned':True}\nunlimited dimensions: x_dim\ncurrent shape = (3,)\n>>> print(f.cmptypes)\n{'complex128': <class 'netCDF4._netCDF4.CompoundType'>: name = 'complex128', numpy dtype = {'names':['real','imag'], 'formats':['<f8','<f8'], 'offsets':[0,8], 'itemsize':16, 'aligned':True}}\n>>> print(f.cmptypes[\"complex128\"])\n<class 'netCDF4._netCDF4.CompoundType'>: name = 'complex128', numpy dtype = {'names':['real','imag'], 'formats':['<f8','<f8'], 'offsets':[0,8], 'itemsize':16, 'aligned':True}\n```\n\n## Variable-length (vlen) data types\n\nNetCDF 4 has support for variable-length or \"ragged\" arrays.  These are arrays\nof variable length sequences having the same type. To create a variable-length\ndata type, use the `Dataset.createVLType` method\nmethod of a `Dataset` or `Group` instance.\n\n```python\n>>> f = Dataset(\"tst_vlen.nc\",\"w\")\n>>> vlen_t = f.createVLType(np.int32, \"phony_vlen\")\n```\n\nThe numpy datatype of the variable-length sequences and the name of the\nnew datatype must be specified. Any of the primitive datatypes can be\nused (signed and unsigned integers, 32 and 64 bit floats, and characters),\nbut compound data types cannot.\nA new variable can then be created using this datatype.\n\n```python\n>>> x = f.createDimension(\"x\",3)\n>>> y = f.createDimension(\"y\",4)\n>>> vlvar = f.createVariable(\"phony_vlen_var\", vlen_t, (\"y\",\"x\"))\n```\n\nSince there is no native vlen datatype in numpy, vlen arrays are represented\nin python as object arrays (arrays of dtype `object`). These are arrays whose\nelements are Python object pointers, and can contain any type of python object.\nFor this application, they must contain 1-D numpy arrays all of the same type\nbut of varying length.\nIn this case, they contain 1-D numpy `int32` arrays of random length between\n1 and 10.\n\n```python\n>>> import random\n>>> random.seed(54321)\n>>> data = np.empty(len(y)*len(x),object)\n>>> for n in range(len(y)*len(x)):\n...     data[n] = np.arange(random.randint(1,10),dtype=\"int32\")+1\n>>> data = np.reshape(data,(len(y),len(x)))\n>>> vlvar[:] = data\n>>> print(\"vlen variable =\\n{}\".format(vlvar[:]))\nvlen variable =\n[[array([1, 2, 3, 4, 5, 6, 7, 8], dtype=int32) array([1, 2], dtype=int32)\n  array([1, 2, 3, 4], dtype=int32)]\n [array([1, 2, 3], dtype=int32)\n  array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int32)\n  array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int32)]\n [array([1, 2, 3, 4, 5, 6, 7], dtype=int32) array([1, 2, 3], dtype=int32)\n  array([1, 2, 3, 4, 5, 6], dtype=int32)]\n [array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int32)\n  array([1, 2, 3, 4, 5], dtype=int32) array([1, 2], dtype=int32)]]\n>>> print(f)\n<class 'netCDF4._netCDF4.Dataset'>\nroot group (NETCDF4 data model, file format HDF5):\n    dimensions(sizes): x(3), y(4)\n    variables(dimensions): int32 phony_vlen_var(y,x)\n    groups:\n>>> print(f.variables[\"phony_vlen_var\"])\n<class 'netCDF4._netCDF4.Variable'>\nvlen phony_vlen_var(y, x)\nvlen data type: int32\nunlimited dimensions:\ncurrent shape = (4, 3)\n>>> print(f.vltypes[\"phony_vlen\"])\n<class 'netCDF4._netCDF4.VLType'>: name = 'phony_vlen', numpy dtype = int32\n```\n\nNumpy object arrays containing python strings can also be written as vlen\nvariables,  For vlen strings, you don't need to create a vlen data type.\nInstead, simply use the python `str` builtin (or a numpy string datatype\nwith fixed length greater than 1) when calling the\n`Dataset.createVariable` method.\n\n```python\n>>> z = f.createDimension(\"z\",10)\n>>> strvar = f.createVariable(\"strvar\", str, \"z\")\n```\n\nIn this example, an object array is filled with random python strings with\nrandom lengths between 2 and 12 characters, and the data in the object\narray is assigned to the vlen string variable.\n\n```python\n>>> chars = \"1234567890aabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n>>> data = np.empty(10,\"O\")\n>>> for n in range(10):\n...     stringlen = random.randint(2,12)\n...     data[n] = \"\".join([random.choice(chars) for i in range(stringlen)])\n>>> strvar[:] = data\n>>> print(\"variable-length string variable:\\n{}\".format(strvar[:]))\nvariable-length string variable:\n['Lh' '25F8wBbMI' '53rmM' 'vvjnb3t63ao' 'qjRBQk6w' 'aJh' 'QF'\n 'jtIJbJACaQk4' '3Z5' 'bftIIq']\n>>> print(f)\n<class 'netCDF4._netCDF4.Dataset'>\nroot group (NETCDF4 data model, file format HDF5):\n    dimensions(sizes): x(3), y(4), z(10)\n    variables(dimensions): int32 phony_vlen_var(y,x), <class 'str'> strvar(z)\n    groups:\n>>> print(f.variables[\"strvar\"])\n<class 'netCDF4._netCDF4.Variable'>\nvlen strvar(z)\nvlen data type: <class 'str'>\nunlimited dimensions:\ncurrent shape = (10,)\n```\n\nIt is also possible to set contents of vlen string variables with numpy arrays\nof any string or unicode data type. Note, however, that accessing the contents\nof such variables will always return numpy arrays with dtype `object`.\n\n## Enum data type\n\nnetCDF4 has an enumerated data type, which is an integer datatype that is\nrestricted to certain named values. Since Enums don't map directly to\na numpy data type, they are read and written as integer arrays.\n\nHere's an example of using an Enum type to hold cloud type data.\nThe base integer data type and a python dictionary describing the allowed\nvalues and their names are used to define an Enum data type using\n`Dataset.createEnumType`.\n\n```python\n>>> nc = Dataset('clouds.nc','w')\n>>> # python dict with allowed values and their names.\n>>> enum_dict = {'Altocumulus': 7, 'Missing': 255,\n... 'Stratus': 2, 'Clear': 0,\n... 'Nimbostratus': 6, 'Cumulus': 4, 'Altostratus': 5,\n... 'Cumulonimbus': 1, 'Stratocumulus': 3}\n>>> # create the Enum type called 'cloud_t'.\n>>> cloud_type = nc.createEnumType(np.uint8,'cloud_t',enum_dict)\n>>> print(cloud_type)\n<class 'netCDF4._netCDF4.EnumType'>: name = 'cloud_t', numpy dtype = uint8, fields/values ={'Altocumulus': 7, 'Missing': 255, 'Stratus': 2, 'Clear': 0, 'Nimbostratus': 6, 'Cumulus': 4, 'Altostratus': 5, 'Cumulonimbus': 1, 'Stratocumulus': 3}\n```\n\nA new variable can be created in the usual way using this data type.\nInteger data is written to the variable that represents the named\ncloud types in enum_dict. A `ValueError` will be raised if an attempt\nis made to write an integer value not associated with one of the\nspecified names.\n\n```python\n>>> time = nc.createDimension('time',None)\n>>> # create a 1d variable of type 'cloud_type'.\n>>> # The fill_value is set to the 'Missing' named value.\n>>> cloud_var = nc.createVariable('primary_cloud',cloud_type,'time',\n...                               fill_value=enum_dict['Missing'])\n>>> # write some data to the variable.\n>>> cloud_var[:] = [enum_dict[k] for k in ['Clear', 'Stratus', 'Cumulus',\n...                                        'Missing', 'Cumulonimbus']]\n>>> nc.close()\n>>> # reopen the file, read the data.\n>>> nc = Dataset('clouds.nc')\n>>> cloud_var = nc.variables['primary_cloud']\n>>> print(cloud_var)\n<class 'netCDF4._netCDF4.Variable'>\nenum primary_cloud(time)\n    _FillValue: 255\nenum data type: uint8\nunlimited dimensions: time\ncurrent shape = (5,)\n>>> print(cloud_var.datatype.enum_dict)\n{'Altocumulus': 7, 'Missing': 255, 'Stratus': 2, 'Clear': 0, 'Nimbostratus': 6, 'Cumulus': 4, 'Altostratus': 5, 'Cumulonimbus': 1, 'Stratocumulus': 3}\n>>> print(cloud_var[:])\n[0 2 4 -- 1]\n>>> nc.close()\n```\n\n## Parallel IO\n\nIf MPI parallel enabled versions of netcdf and hdf5 or pnetcdf are detected,\nand [mpi4py](https://mpi4py.scipy.org) is installed, netcdf4-python will\nbe built with parallel IO capabilities enabled. Parallel IO of NETCDF4 or\nNETCDF4_CLASSIC formatted files is only available if the MPI parallel HDF5\nlibrary is available. Parallel IO of classic netcdf-3 file formats is only\navailable if the [PnetCDF](https://parallel-netcdf.github.io/) library is\navailable. To use parallel IO, your program must be running in an MPI\nenvironment using [mpi4py](https://mpi4py.scipy.org).\n\n```python\n>>> from mpi4py import MPI\n>>> import numpy as np\n>>> from netCDF4 import Dataset\n>>> rank = MPI.COMM_WORLD.rank  # The process ID (integer 0-3 for 4-process run)\n```\n\nTo run an MPI-based parallel program like this, you must use `mpiexec` to launch several\nparallel instances of Python (for example, using `mpiexec -np 4 python mpi_example.py`).\nThe parallel features of netcdf4-python are mostly transparent -\nwhen a new dataset is created or an existing dataset is opened,\nuse the `parallel` keyword to enable parallel access.\n\n```python\n>>> nc = Dataset('parallel_test.nc','w',parallel=True)\n```\n\nThe optional `comm` keyword may be used to specify a particular\nMPI communicator (`MPI_COMM_WORLD` is used by default).  Each process (or rank)\ncan now write to the file indepedently.  In this example the process rank is\nwritten to a different variable index on each task\n\n```python\n>>> d = nc.createDimension('dim',4)\n>>> v = nc.createVariable('var', np.int64, 'dim')\n>>> v[rank] = rank\n>>> nc.close()\n\n% ncdump parallel_test.nc\nnetcdf parallel_test {\ndimensions:\n    dim = 4 ;\nvariables:\n    int64 var(dim) ;\ndata:\n\n    var = 0, 1, 2, 3 ;\n}\n```\n\nThere are two types of parallel IO, independent (the default) and collective.\nIndependent IO means that each process can do IO independently. It should not\ndepend on or be affected by other processes. Collective IO is a way of doing\nIO defined in the MPI-IO standard; unlike independent IO, all processes must\nparticipate in doing IO. To toggle back and forth between\nthe two types of IO, use the `Variable.set_collective`\n`Variable` method. All metadata\noperations (such as creation of groups, types, variables, dimensions, or attributes)\nare collective.  There are a couple of important limitations of parallel IO:\n\n - parallel IO for NETCDF4 or NETCDF4_CLASSIC formatted files is only available\n   if the netcdf library was compiled with MPI enabled HDF5.\n - parallel IO for all classic netcdf-3 file formats is only available if the\n   netcdf library was compiled with [PnetCDF](https://parallel-netcdf.github.io).\n - If a variable has an unlimited dimension, appending data must be done in collective mode.\n   If the write is done in independent mode, the operation will fail with a\n   a generic \"HDF Error\".\n - You can write compressed data in parallel only with netcdf-c >= 4.7.4\n   and hdf5 >= 1.10.3 (although you can read in parallel with earlier versions). To write\n   compressed data in parallel, the variable must be in 'collective IO mode'.  This is done\n   automatically on variable creation if compression is turned on, but if you are appending\n   to a variable in an existing file, you must use `Variable.set_collective(True)` before attempting\n   to write to it.\n - You cannot use variable-length (VLEN) data types.\n\n## Dealing with strings\n\nThe most flexible way to store arrays of strings is with the\n[Variable-length (vlen) string data type](#variable-length-vlen-data-type). However, this requires\nthe use of the NETCDF4 data model, and the vlen type does not map very well\nnumpy arrays (you have to use numpy arrays of dtype=`object`, which are arrays of\narbitrary python objects). numpy does have a fixed-width string array\ndata type, but unfortunately the netCDF data model does not.\nInstead fixed-width byte strings are typically stored as [arrays of 8-bit\ncharacters](https://www.unidata.ucar.edu/software/netcdf/docs/BestPractices.html#bp_Strings-and-Variables-of-type-char).\nTo perform the conversion to and from character arrays to fixed-width numpy string arrays, the\nfollowing convention is followed by the python interface.\nIf the `_Encoding` special attribute is set for a character array\n(dtype `S1`) variable, the `chartostring` utility function is used to convert the array of\ncharacters to an array of strings with one less dimension (the last dimension is\ninterpreted as the length of each string) when reading the data. The character\nset (usually ascii) is specified by the `_Encoding` attribute. If `_Encoding`\nis 'none' or 'bytes', then the character array is converted to a numpy\nfixed-width byte string array (dtype `S#`), otherwise a numpy unicode (dtype\n`U#`) array is created.  When writing the data,\n`stringtochar` is used to convert the numpy string array to an array of\ncharacters with one more dimension. For example,\n\n```python\n>>> from netCDF4 import stringtochar\n>>> nc = Dataset('stringtest.nc','w',format='NETCDF4_CLASSIC')\n>>> _ = nc.createDimension('nchars',3)\n>>> _ = nc.createDimension('nstrings',None)\n>>> v = nc.createVariable('strings','S1',('nstrings','nchars'))\n>>> datain = np.array(['foo','bar'],dtype='S3')\n>>> v[:] = stringtochar(datain) # manual conversion to char array\n>>> print(v[:]) # data returned as char array\n[[b'f' b'o' b'o']\n [b'b' b'a' b'r']]\n>>> v._Encoding = 'ascii' # this enables automatic conversion\n>>> v[:] = datain # conversion to char array done internally\n>>> print(v[:])  # data returned in numpy string array\n['foo' 'bar']\n>>> nc.close()\n```\n\nEven if the `_Encoding` attribute is set, the automatic conversion of char\narrays to/from string arrays can be disabled with\n`Variable.set_auto_chartostring`.\n\nA similar situation is often encountered with numpy structured arrays with subdtypes\ncontaining fixed-wdith byte strings (dtype=`S#`). Since there is no native fixed-length string\nnetCDF datatype, these numpy structure arrays are mapped onto netCDF compound\ntypes with character array elements.  In this case the string <-> char array\nconversion is handled automatically (without the need to set the `_Encoding`\nattribute) using [numpy\nviews](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.view.html).\nThe structured array dtype (including the string elements) can even be used to\ndefine the compound data type - the string dtype will be converted to\ncharacter array dtype under the hood when creating the netcdf compound type.\nHere's an example:\n\n```python\n>>> nc = Dataset('compoundstring_example.nc','w')\n>>> dtype = np.dtype([('observation', 'f4'),\n...                      ('station_name','S10')])\n>>> station_data_t = nc.createCompoundType(dtype,'station_data')\n>>> _ = nc.createDimension('station',None)\n>>> statdat = nc.createVariable('station_obs', station_data_t, ('station',))\n>>> data = np.empty(2,dtype)\n>>> data['observation'][:] = (123.,3.14)\n>>> data['station_name'][:] = ('Boulder','New York')\n>>> print(statdat.dtype) # strings actually stored as character arrays\n{'names':['observation','station_name'], 'formats':['<f4',('S1', (10,))], 'offsets':[0,4], 'itemsize':16, 'aligned':True}\n>>> statdat[:] = data # strings converted to character arrays internally\n>>> print(statdat[:])  # character arrays converted back to strings\n[(123.  , b'Boulder') (  3.14, b'New York')]\n>>> print(statdat[:].dtype)\n{'names':['observation','station_name'], 'formats':['<f4','S10'], 'offsets':[0,4], 'itemsize':16, 'aligned':True}\n>>> statdat.set_auto_chartostring(False) # turn off auto-conversion\n>>> statdat[:] = data.view(dtype=[('observation', 'f4'),('station_name','S1',10)])\n>>> print(statdat[:])  # now structured array with char array subtype is returned\n[(123.  , [b'B', b'o', b'u', b'l', b'd', b'e', b'r', b'', b'', b''])\n (  3.14, [b'N', b'e', b'w', b' ', b'Y', b'o', b'r', b'k', b'', b''])]\n>>> nc.close()\n```\n\nNote that there is currently no support for mapping numpy structured arrays with\nunicode elements (dtype `U#`) onto netCDF compound types, nor is there support\nfor netCDF compound types with vlen string components.\n\n## In-memory (diskless) Datasets\n\nYou can create netCDF Datasets whose content is held in memory\ninstead of in a disk file.  There are two ways to do this.  If you\ndon't need access to the memory buffer containing the Dataset from\nwithin python, the best way is to use the `diskless=True` keyword\nargument when creating the Dataset.  If you want to save the Dataset\nto disk when you close it, also set `persist=True`.  If you want to\ncreate a new read-only Dataset from an existing python memory buffer, use the\n`memory` keyword argument to pass the memory buffer when creating the Dataset.\nIf you want to create a new in-memory Dataset, and then access the memory buffer\ndirectly from Python, use the `memory` keyword argument to specify the\nestimated size of the Dataset in bytes when creating the Dataset with\n`mode='w'`.  Then, the `Dataset.close` method will return a python memoryview\nobject representing the Dataset. Below are examples illustrating both\napproaches.\n\n```python\n>>> # create a diskless (in-memory) Dataset,\n>>> # and persist the file to disk when it is closed.\n>>> nc = Dataset('diskless_example.nc','w',diskless=True,persist=True)\n>>> d = nc.createDimension('x',None)\n>>> v = nc.createVariable('v',np.int32,'x')\n>>> v[0:5] = np.arange(5)\n>>> print(nc)\n<class 'netCDF4._netCDF4.Dataset'>\nroot group (NETCDF4 data model, file format HDF5):\n    dimensions(sizes): x(5)\n    variables(dimensions): int32 v(x)\n    groups:\n>>> print(nc['v'][:])\n[0 1 2 3 4]\n>>> nc.close() # file saved to disk\n>>> # create an in-memory dataset from an existing python\n>>> # python memory buffer.\n>>> # read the newly created netcdf file into a python\n>>> # bytes object.\n>>> with open('diskless_example.nc', 'rb') as f:\n...     nc_bytes = f.read()\n>>> # create a netCDF in-memory dataset from the bytes object.\n>>> nc = Dataset('inmemory.nc', memory=nc_bytes)\n>>> print(nc)\n<class 'netCDF4._netCDF4.Dataset'>\nroot group (NETCDF4 data model, file format HDF5):\n    dimensions(sizes): x(5)\n    variables(dimensions): int32 v(x)\n    groups:\n>>> print(nc['v'][:])\n[0 1 2 3 4]\n>>> nc.close()\n>>> # create an in-memory Dataset and retrieve memory buffer\n>>> # estimated size is 1028 bytes - this is actually only\n>>> # used if format is NETCDF3\n>>> # (ignored for NETCDF4/HDF5 files).\n>>> nc = Dataset('inmemory.nc', mode='w',memory=1028)\n>>> d = nc.createDimension('x',None)\n>>> v = nc.createVariable('v',np.int32,'x')\n>>> v[0:5] = np.arange(5)\n>>> nc_buf = nc.close() # close returns memoryview\n>>> print(type(nc_buf))\n<class 'memoryview'>\n>>> # save nc_buf to disk, read it back in and check.\n>>> with open('inmemory.nc', 'wb') as f:\n...     f.write(nc_buf)\n>>> nc = Dataset('inmemory.nc')\n>>> print(nc)\n<class 'netCDF4._netCDF4.Dataset'>\nroot group (NETCDF4 data model, file format HDF5):\n    dimensions(sizes): x(5)\n    variables(dimensions): int32 v(x)\n    groups:\n>>> print(nc['v'][:])\n[0 1 2 3 4]\n>>> nc.close()\n```\n\n## Support for complex numbers\n\nAlthough there is no native support for complex numbers in netCDF, there are\nsome common conventions for storing them. Two of the most common are to either\nuse a compound datatype for the real and imaginary components, or a separate\ndimension. `netCDF4` supports reading several of these conventions, as well as\nwriting using one of two conventions (depending on file format). This support\nfor complex numbers is enabled by setting `auto_complex=True` when opening a\n`Dataset`:\n\n```python\n>>> complex_array = np.array([0 + 0j, 1 + 0j, 0 + 1j, 1 + 1j, 0.25 + 0.75j])\n>>> with netCDF4.Dataset(\"complex.nc\", \"w\", auto_complex=True) as nc:\n...     nc.createDimension(\"x\", size=len(complex_array))\n...     var = nc.createVariable(\"data\", \"c16\", (\"x\",))\n...     var[:] = complex_array\n...     print(var)\n<class 'netCDF4._netCDF4.Variable'>\ncompound data(x)\ncompound data type: complex128\nunlimited dimensions:\ncurrent shape = (5,)\n```\n\nWhen reading files using `auto_complex=True`, `netCDF4` will interpret variables\nstored using the following conventions as complex numbers:\n\n- compound datatypes with two `float` or `double` members who names begin with\n  `r` and `i` (case insensitive)\n- a dimension of length 2 named `complex` or `ri`\n\nWhen writing files using `auto_complex=True`, `netCDF4` will use:\n\n- a compound datatype named `_PFNC_DOUBLE_COMPLEX_TYPE` (or `*FLOAT*` as\n  appropriate) with members `r` and `i` for netCDF4 formats;\n- or a dimension of length 2 named `_pfnc_complex` for netCDF3 or classic\n  formats.\n\nSupport for complex numbers is handled via the\n[`nc-complex`](https://github.com/PlasmaFAIR/nc-complex) library. See there for\nfurther details.\n\n\n**contact**: Jeffrey Whitaker <jeffrey.s.whitaker@noaa.gov>\n\n**copyright**: 2008 by Jeffrey Whitaker.\n\n**license**: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n",
  "netCDF4._netCDF4.CompoundType": "\nA `CompoundType` instance is used to describe a compound data\ntype, and can be passed to the the `Dataset.createVariable` method of\na `Dataset` or `Group` instance.\nCompound data types map to numpy structured arrays.\nSee `CompoundType.__init__` for more details.\n\nThe instance variables `dtype` and `name` should not be modified by\nthe user.\n    ",
  "netCDF4._netCDF4.CompoundType.__init__": "\n        ***`__init__(group, datatype, datatype_name)`***\n\n        CompoundType constructor.\n\n        **`group`**: `Group` instance to associate with the compound datatype.\n\n        **`datatype`**: A numpy dtype object describing a structured (a.k.a record)\n        array.  Can be composed of homogeneous numeric or character data types, or\n        other structured array data types.\n\n        **`datatype_name`**: a Python string containing a description of the\n        compound data type.\n\n        ***Note 1***: When creating nested compound data types,\n        the inner compound data types must already be associated with CompoundType\n        instances (so create CompoundType instances for the innermost structures\n        first).\n\n        ***Note 2***: `CompoundType` instances should be created using the\n        `Dataset.createCompoundType` method of a `Dataset` or\n        `Group` instance, not using this class directly.\n        ",
  "netCDF4._netCDF4.CompoundType.__str__": "Return str(self).",
  "netCDF4._netCDF4.Dataset": "\nA netCDF `Dataset` is a collection of dimensions, groups, variables and\nattributes. Together they describe the meaning of data and relations among\ndata fields stored in a netCDF file. See `Dataset.__init__` for more\ndetails.\n\nA list of attribute names corresponding to global netCDF attributes\ndefined for the `Dataset` can be obtained with the\n`Dataset.ncattrs` method.\nThese attributes can be created by assigning to an attribute of the\n`Dataset` instance. A dictionary containing all the netCDF attribute\nname/value pairs is provided by the `__dict__` attribute of a\n`Dataset` instance.\n\nThe following class variables are read-only and should not be\nmodified by the user.\n\n**`dimensions`**: The `dimensions` dictionary maps the names of\ndimensions defined for the `Group` or `Dataset` to instances of the\n`Dimension` class.\n\n**`variables`**: The `variables` dictionary maps the names of variables\ndefined for this `Dataset` or `Group` to instances of the\n`Variable` class.\n\n**`groups`**: The groups dictionary maps the names of groups created for\nthis `Dataset` or `Group` to instances of the `Group` class (the\n`Dataset` class is simply a special case of the `Group` class which\ndescribes the root group in the netCDF4 file).\n\n**`cmptypes`**: The `cmptypes` dictionary maps the names of\ncompound types defined for the `Group` or `Dataset` to instances of the\n`CompoundType` class.\n\n**`vltypes`**: The `vltypes` dictionary maps the names of\nvariable-length types defined for the `Group` or `Dataset` to instances\nof the `VLType` class.\n\n**`enumtypes`**: The `enumtypes` dictionary maps the names of\nEnum types defined for the `Group` or `Dataset` to instances\nof the `EnumType` class.\n\n**`data_model`**: `data_model` describes the netCDF\ndata model version, one of `NETCDF3_CLASSIC`, `NETCDF4`,\n`NETCDF4_CLASSIC`, `NETCDF3_64BIT_OFFSET` or `NETCDF3_64BIT_DATA`.\n\n**`file_format`**: same as `data_model`, retained for backwards compatibility.\n\n**`disk_format`**: `disk_format` describes the underlying\nfile format, one of `NETCDF3`, `HDF5`, `HDF4`,\n`PNETCDF`, `DAP2`, `DAP4` or `UNDEFINED`. Only available if using\nnetcdf C library version >= 4.3.1, otherwise will always return\n`UNDEFINED`.\n\n**`parent`**: `parent` is a reference to the parent\n`Group` instance. `None` for the root group or `Dataset`\ninstance.\n\n**`path`**: `path` shows the location of the `Group` in\nthe `Dataset` in a unix directory format (the names of groups in the\nhierarchy separated by backslashes). A `Dataset` instance is the root\ngroup, so the path is simply `'/'`.\n\n**`keepweakref`**: If `True`, child Dimension and Variables objects only keep weak\nreferences to the parent Dataset or Group.\n\n**`_ncstring_attrs__`**: If `True`, all text attributes will be written as variable-length\nstrings.\n    ",
  "netCDF4._netCDF4.Dataset.__delattr__": "Implement delattr(self, name).",
  "netCDF4._netCDF4.Dataset.__getattribute__": "Return getattr(self, name).",
  "netCDF4._netCDF4.Dataset.__getitem__": "Return self[key].",
  "netCDF4._netCDF4.Dataset.__init__": "\n        **`__init__(self, filename, mode=\"r\", clobber=True, diskless=False,\n        persist=False, keepweakref=False, memory=None, encoding=None,\n        parallel=False, comm=None, info=None, format='NETCDF4')`**\n\n        `Dataset` constructor.\n\n        **`filename`**: Name of netCDF file to hold dataset. Can also\n        be a python 3 pathlib instance or the URL of an OpenDAP dataset.  When memory is\n        set this is just used to set the `filepath()`.\n\n        **`mode`**: access mode. `r` means read-only; no data can be\n        modified. `w` means write; a new file is created, an existing file with\n        the same name is deleted. `x` means write, but fail if an existing\n        file with the same name already exists. `a` and `r+` mean append;\n        an existing file is opened for reading and writing, if\n        file does not exist already, one is created.\n        Appending `s` to modes `r`, `w`, `r+` or `a` will enable unbuffered shared\n        access to `NETCDF3_CLASSIC`, `NETCDF3_64BIT_OFFSET` or\n        `NETCDF3_64BIT_DATA` formatted files.\n        Unbuffered access may be useful even if you don't need shared\n        access, since it may be faster for programs that don't access data\n        sequentially. This option is ignored for `NETCDF4` and `NETCDF4_CLASSIC`\n        formatted files.\n\n        **`clobber`**: if `True` (default), opening a file with `mode='w'`\n        will clobber an existing file with the same name.  if `False`, an\n        exception will be raised if a file with the same name already exists.\n        mode=`x` is identical to mode=`w` with clobber=False.\n\n        **`format`**: underlying file format (one of `'NETCDF4',\n        'NETCDF4_CLASSIC', 'NETCDF3_CLASSIC'`, `'NETCDF3_64BIT_OFFSET'` or\n        `'NETCDF3_64BIT_DATA'`.\n        Only relevant if `mode = 'w'` (if `mode = 'r','a'` or `'r+'` the file format\n        is automatically detected). Default `'NETCDF4'`, which means the data is\n        stored in an HDF5 file, using netCDF 4 API features.  Setting\n        `format='NETCDF4_CLASSIC'` will create an HDF5 file, using only netCDF 3\n        compatible API features. netCDF 3 clients must be recompiled and linked\n        against the netCDF 4 library to read files in `NETCDF4_CLASSIC` format.\n        `'NETCDF3_CLASSIC'` is the classic netCDF 3 file format that does not\n        handle 2+ Gb files. `'NETCDF3_64BIT_OFFSET'` is the 64-bit offset\n        version of the netCDF 3 file format, which fully supports 2+ GB files, but\n        is only compatible with clients linked against netCDF version 3.6.0 or\n        later. `'NETCDF3_64BIT_DATA'` is the 64-bit data version of the netCDF 3\n        file format, which supports 64-bit dimension sizes plus unsigned and\n        64 bit integer data types, but is only compatible with clients linked against\n        netCDF version 4.4.0 or later.\n\n        **`diskless`**: If `True`, create diskless (in-core) file.\n        This is a feature added to the C library after the\n        netcdf-4.2 release. If you need to access the memory buffer directly,\n        use the in-memory feature instead (see `memory` kwarg).\n\n        **`persist`**: if `diskless=True`, persist file to disk when closed\n        (default `False`).\n\n        **`keepweakref`**: if `True`, child Dimension and Variable instances will keep weak\n        references to the parent Dataset or Group object.  Default is `False`, which\n        means strong references will be kept.  Having Dimension and Variable instances\n        keep a strong reference to the parent Dataset instance, which in turn keeps a\n        reference to child Dimension and Variable instances, creates circular references.\n        Circular references complicate garbage collection, which may mean increased\n        memory usage for programs that create may Dataset instances with lots of\n        Variables. It also will result in the Dataset object never being deleted, which\n        means it may keep open files alive as well. Setting `keepweakref=True` allows\n        Dataset instances to be garbage collected as soon as they go out of scope, potentially\n        reducing memory usage and open file handles.  However, in many cases this is not\n        desirable, since the associated Variable instances may still be needed, but are\n        rendered unusable when the parent Dataset instance is garbage collected.\n\n        **`memory`**: if not `None`, create or open an in-memory Dataset.\n        If mode = `r`, the memory kwarg must contain a memory buffer object\n        (an object that supports the python buffer interface).\n        The Dataset will then be created with contents taken from this block of memory.\n        If mode = `w`, the memory kwarg should contain the anticipated size\n        of the Dataset in bytes (used only for NETCDF3 files).  A memory\n        buffer containing a copy of the Dataset is returned by the\n        `Dataset.close` method. Requires netcdf-c version 4.4.1 for mode=`r`\n        netcdf-c 4.6.2 for mode=`w`. To persist the file to disk, the raw\n        bytes from the returned buffer can be written into a binary file.\n        The Dataset can also be re-opened using this memory buffer.\n\n        **`encoding`**: encoding used to encode filename string into bytes.\n        Default is None (`sys.getdefaultfileencoding()` is used).\n\n        **`parallel`**: open for parallel access using MPI (requires mpi4py and\n        parallel-enabled netcdf-c and hdf5 libraries).  Default is `False`. If\n        `True`, `comm` and `info` kwargs may also be specified.\n\n        **`comm`**: MPI_Comm object for parallel access. Default `None`, which\n        means MPI_COMM_WORLD will be used.  Ignored if `parallel=False`.\n\n        **`info`**: MPI_Info object for parallel access. Default `None`, which\n        means MPI_INFO_NULL will be used.  Ignored if `parallel=False`.\n\n        **`auto_complex`**: if `True`, then automatically convert complex number types\n        ",
  "netCDF4._netCDF4.Dataset.__setattr__": "Implement setattr(self, name, value).",
  "netCDF4._netCDF4.Dataset.__str__": "Return str(self).",
  "netCDF4._netCDF4.Dataset.close": "**`close(self)`**\n\n        Close the Dataset.\n        ",
  "netCDF4._netCDF4.Dataset.createCompoundType": "\n**`createCompoundType(self, datatype, datatype_name)`**\n\nCreates a new compound data type named `datatype_name` from the numpy\ndtype object `datatype`.\n\n***Note***: If the new compound data type contains other compound data types\n(i.e. it is a 'nested' compound type, where not all of the elements\nare homogeneous numeric data types), then the 'inner' compound types **must** be\ncreated first.\n\nThe return value is the `CompoundType` class instance describing the new\ndatatype.",
  "netCDF4._netCDF4.Dataset.createDimension": "\n**`createDimension(self, dimname, size=None)`**\n\nCreates a new dimension with the given `dimname` and `size`.\n\n`size` must be a positive integer or `None`, which stands for\n\"unlimited\" (default is `None`). Specifying a size of 0 also\nresults in an unlimited dimension. The return value is the `Dimension`\nclass instance describing the new dimension.  To determine the current\nmaximum size of the dimension, use the `len` function on the `Dimension`\ninstance. To determine if a dimension is 'unlimited', use the\n`Dimension.isunlimited` method of the `Dimension` instance.",
  "netCDF4._netCDF4.Dataset.createEnumType": "\n**`createEnumType(self, datatype, datatype_name, enum_dict)`**\n\nCreates a new Enum data type named `datatype_name` from a numpy\ninteger dtype object `datatype`, and a python dictionary\ndefining the enum fields and values.\n\nThe return value is the `EnumType` class instance describing the new\ndatatype.",
  "netCDF4._netCDF4.Dataset.createGroup": "\n**`createGroup(self, groupname)`**\n\nCreates a new `Group` with the given `groupname`.\n\nIf `groupname` is specified as a path, using forward slashes as in unix to\nseparate components, then intermediate groups will be created as necessary\n(analogous to `mkdir -p` in unix).  For example,\n`createGroup('/GroupA/GroupB/GroupC')` will create `GroupA`,\n`GroupA/GroupB`, and `GroupA/GroupB/GroupC`, if they don't already exist.\nIf the specified path describes a group that already exists, no error is\nraised.\n\nThe return value is a `Group` class instance.",
  "netCDF4._netCDF4.Dataset.createVLType": "\n**`createVLType(self, datatype, datatype_name)`**\n\nCreates a new VLEN data type named `datatype_name` from a numpy\ndtype object `datatype`.\n\nThe return value is the `VLType` class instance describing the new\ndatatype.",
  "netCDF4._netCDF4.Dataset.createVariable": "\n**`createVariable(self, varname, datatype, dimensions=(), compression=None, zlib=False,\ncomplevel=4, shuffle=True, fletcher32=False, contiguous=False, chunksizes=None,\nszip_coding='nn', szip_pixels_per_block=8, blosc_shuffle=1,\nendian='native', least_significant_digit=None, significant_digits=None, quantize_mode='BitGroom',\nfill_value=None, chunk_cache=None)`**\n\nCreates a new variable with the given `varname`, `datatype`, and\n`dimensions`. If dimensions are not given, the variable is assumed to be\na scalar.\n\nIf `varname` is specified as a path, using forward slashes as in unix to\nseparate components, then intermediate groups will be created as necessary\nFor example, `createVariable('/GroupA/GroupB/VarC', float, ('x','y'))` will create groups `GroupA`\nand `GroupA/GroupB`, plus the variable `GroupA/GroupB/VarC`, if the preceding\ngroups don't already exist.\n\nThe `datatype` can be a numpy datatype object, or a string that describes\na numpy dtype object (like the `dtype.str` attribute of a numpy array).\nSupported specifiers include: `'S1' or 'c' (NC_CHAR), 'i1' or 'b' or 'B'\n(NC_BYTE), 'u1' (NC_UBYTE), 'i2' or 'h' or 's' (NC_SHORT), 'u2'\n(NC_USHORT), 'i4' or 'i' or 'l' (NC_INT), 'u4' (NC_UINT), 'i8' (NC_INT64),\n'u8' (NC_UINT64), 'f4' or 'f' (NC_FLOAT), 'f8' or 'd' (NC_DOUBLE)`.\n`datatype` can also be a `CompoundType` instance\n(for a structured, or compound array), a `VLType` instance\n(for a variable-length array), or the python `str` builtin\n(for a variable-length string array). Numpy string and unicode datatypes with\nlength greater than one are aliases for `str`.\n\nData from netCDF variables is presented to python as numpy arrays with\nthe corresponding data type.\n\n`dimensions` must be a tuple containing `Dimension` instances and/or\ndimension names (strings) that have been defined\npreviously using `Dataset.createDimension`. The default value\nis an empty tuple, which means the variable is a scalar.\n\nIf the optional keyword argument `compression` is set, the data will be\ncompressed in the netCDF file using the specified compression algorithm.\nCurrently `zlib`,`szip`,`zstd`,`bzip2`,`blosc_lz`,`blosc_lz4`,`blosc_lz4hc`,\n`blosc_zlib` and `blosc_zstd` are supported.\nDefault is `None` (no compression).  All of the compressors except\n`zlib` and `szip` use the HDF5 plugin architecture.\n\nIf the optional keyword `zlib` is `True`, the data will be compressed in\nthe netCDF file using zlib compression (default `False`).  The use of this option is\ndeprecated in favor of `compression='zlib'`.\n\nThe optional keyword `complevel` is an integer between 0 and 9 describing\nthe level of compression desired (default 4). Ignored if `compression=None`.\nA value of zero disables compression.\n\nIf the optional keyword `shuffle` is `True`, the HDF5 shuffle filter\nwill be applied before compressing the data with zlib (default `True`).  This\nsignificantly improves compression. Default is `True`. Ignored if\n`zlib=False`.\n\nThe optional kwarg `blosc_shuffle`is  ignored\nunless the blosc compressor is used. `blosc_shuffle` can be 0 (no shuffle),\n1 (byte-wise shuffle) or 2 (bit-wise shuffle). Default is 1.\n\nThe optional kwargs `szip_coding` and `szip_pixels_per_block` are ignored\nunless the szip compressor is used. `szip_coding` can be `ec` (entropy coding)\nor `nn` (nearest neighbor coding). Default is `nn`. `szip_pixels_per_block`\ncan be 4, 8, 16 or 32 (default 8).\n\nIf the optional keyword `fletcher32` is `True`, the Fletcher32 HDF5\nchecksum algorithm is activated to detect errors. Default `False`.\n\nIf the optional keyword `contiguous` is `True`, the variable data is\nstored contiguously on disk.  Default `False`. Setting to `True` for\na variable with an unlimited dimension will trigger an error.\nFixed size variables (with no unlimited dimension) with no compression filters\nare contiguous by default.\n\nThe optional keyword `chunksizes` can be used to manually specify the\nHDF5 chunksizes for each dimension of the variable.\nA detailed discussion of HDF chunking and I/O performance is available\n[here](https://support.hdfgroup.org/HDF5/doc/Advanced/Chunking).\nThe default chunking scheme in the netcdf-c library is discussed\n[here](https://www.unidata.ucar.edu/software/netcdf/documentation/NUG/netcdf_perf_chunking.html).\nBasically, you want the chunk size for each dimension to match as\nclosely as possible the size of the data block that users will read\nfrom the file. `chunksizes` cannot be set if `contiguous=True`.\n\nThe optional keyword `endian` can be used to control whether the\ndata is stored in little or big endian format on disk. Possible\nvalues are `little, big` or `native` (default). The library\nwill automatically handle endian conversions when the data is read,\nbut if the data is always going to be read on a computer with the\nopposite format as the one used to create the file, there may be\nsome performance advantage to be gained by setting the endian-ness.\n\nThe optional keyword `fill_value` can be used to override the default\nnetCDF `_FillValue` (the value that the variable gets filled with before\nany data is written to it, defaults given in the dict `netCDF4.default_fillvals`).\nIf fill_value is set to `False`, then the variable is not pre-filled.\n\nIf the optional keyword parameters `least_significant_digit` or `significant_digits` are\nspecified, variable data will be truncated (quantized). In conjunction\nwith `compression='zlib'` this produces 'lossy', but significantly more\nefficient compression. For example, if `least_significant_digit=1`,\ndata will be quantized using `numpy.around(scale*data)/scale`, where\nscale = 2**bits, and bits is determined so that a precision of 0.1 is\nretained (in this case bits=4). From the\n[PSL metadata conventions](http://www.esrl.noaa.gov/psl/data/gridded/conventions/cdc_netcdf_standard.shtml):\n\"least_significant_digit -- power of ten of the smallest decimal place\nin unpacked data that is a reliable value.\" Default is `None`, or no\nquantization, or 'lossless' compression.  If `significant_digits=3`\nthen the data will be quantized so that three significant digits are retained, independent\nof the floating point exponent. The keyword argument `quantize_mode` controls\nthe quantization algorithm (default 'BitGroom', 'BitRound' and\n'GranularBitRound' also available).  The 'GranularBitRound'\nalgorithm may result in better compression for typical geophysical datasets.\nThis `significant_digits` kwarg is only available  with netcdf-c >= 4.9.0, and\nonly works with `NETCDF4` or `NETCDF4_CLASSIC` formatted files.\n\nWhen creating variables in a `NETCDF4` or `NETCDF4_CLASSIC` formatted file,\nHDF5 creates something called a 'chunk cache' for each variable.  The\ndefault size of the chunk cache may be large enough to completely fill\navailable memory when creating thousands of variables.  The optional\nkeyword `chunk_cache` allows you to reduce (or increase) the size of\nthe default chunk cache when creating a variable.  The setting only\npersists as long as the Dataset is open - you can use the set_var_chunk_cache\nmethod to change it the next time the Dataset is opened.\nWarning - messing with this parameter can seriously degrade performance.\n\nThe return value is the `Variable` class instance describing the new\nvariable.\n\nA list of names corresponding to netCDF variable attributes can be\nobtained with the `Variable` method `Variable.ncattrs`. A dictionary\ncontaining all the netCDF attribute name/value pairs is provided by\nthe `__dict__` attribute of a `Variable` instance.\n\n`Variable` instances behave much like array objects. Data can be\nassigned to or retrieved from a variable with indexing and slicing\noperations on the `Variable` instance. A `Variable` instance has six\nDataset standard attributes: `dimensions, dtype, shape, ndim, name` and\n`least_significant_digit`. Application programs should never modify\nthese attributes. The `dimensions` attribute is a tuple containing the\nnames of the dimensions associated with this variable. The `dtype`\nattribute is a string describing the variable's data type (`i4, f8,\nS1,` etc). The `shape` attribute is a tuple describing the current\nsizes of all the variable's dimensions. The `name` attribute is a\nstring containing the name of the Variable instance.\nThe `least_significant_digit`\nattributes describes the power of ten of the smallest decimal place in\nthe data the contains a reliable value.  assigned to the `Variable`\ninstance. The `ndim` attribute\nis the number of variable dimensions.",
  "netCDF4._netCDF4.Dataset.delncattr": "\n**`delncattr(self,name,value)`**\n\ndelete a netCDF dataset or group attribute.  Use if you need to delete a\nnetCDF attribute with the same name as one of the reserved python\nattributes.",
  "netCDF4._netCDF4.Dataset.filepath": "**`filepath(self,encoding=None)`**\n\n        Get the file system path (or the opendap URL) which was used to\n        open/create the Dataset. Requires netcdf >= 4.1.2.  The path\n        is decoded into a string using `sys.getfilesystemencoding()` by default, this can be\n        changed using the `encoding` kwarg.\n        ",
  "netCDF4._netCDF4.Dataset.fromcdl": "\n**`fromcdl(cdlfilename, ncfilename=None, mode='a',format='NETCDF4')`**\n\ncall [ncgen][ncgen] via subprocess to create Dataset from [CDL][cdl]\ntext representation. Requires [ncgen][ncgen] to be installed and in `$PATH`.\n\n**`cdlfilename`**:  CDL file.\n\n**`ncfilename`**: netCDF file to create. If not given, CDL filename with\nsuffix replaced by `.nc` is used..\n\n**`mode`**:  Access mode to open Dataset (Default `'a'`).\n\n**`format`**: underlying file format to use (one of `'NETCDF4',\n'NETCDF4_CLASSIC', 'NETCDF3_CLASSIC'`, `'NETCDF3_64BIT_OFFSET'` or\n`'NETCDF3_64BIT_DATA'`. Default `'NETCDF4'`.\n\nDataset instance for `ncfilename` is returned.\n\n[ncgen]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#ncgen_guide\n[cdl]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#cdl_guide\n        ",
  "netCDF4._netCDF4.Dataset.get_variables_by_attributes": "\n**`get_variables_by_attributes(self, **kwargs)`**\n\nReturns a list of variables that match specific conditions.\n\nCan pass in key=value parameters and variables are returned that\ncontain all of the matches. For example,\n\n```python\n>>> # Get variables with x-axis attribute.\n>>> vs = nc.get_variables_by_attributes(axis='X')\n>>> # Get variables with matching \"standard_name\" attribute\n>>> vs = nc.get_variables_by_attributes(standard_name='northward_sea_water_velocity')\n```\n\nCan pass in key=callable parameter and variables are returned if the\ncallable returns True.  The callable should accept a single parameter,\nthe attribute value.  None is given as the attribute value when the\nattribute does not exist on the variable. For example,\n\n```python\n>>> # Get Axis variables\n>>> vs = nc.get_variables_by_attributes(axis=lambda v: v in ['X', 'Y', 'Z', 'T'])\n>>> # Get variables that don't have an \"axis\" attribute\n>>> vs = nc.get_variables_by_attributes(axis=lambda v: v is None)\n>>> # Get variables that have a \"grid_mapping\" attribute\n>>> vs = nc.get_variables_by_attributes(grid_mapping=lambda v: v is not None)\n```\n",
  "netCDF4._netCDF4.Dataset.getncattr": "\n**`getncattr(self,name)`**\n\nretrieve a netCDF dataset or group attribute.\nUse if you need to get a netCDF attribute with the same\nname as one of the reserved python attributes.\n\noption kwarg `encoding` can be used to specify the\ncharacter encoding of a string attribute (default is `utf-8`).",
  "netCDF4._netCDF4.Dataset.has_blosc_filter": "**`has_blosc_filter(self)`**\n        returns True if blosc compression filter is available\n        ",
  "netCDF4._netCDF4.Dataset.has_bzip2_filter": "**`has_bzip2_filter(self)`**\n        returns True if bzip2 compression filter is available\n        ",
  "netCDF4._netCDF4.Dataset.has_szip_filter": "**`has_szip_filter(self)`**\n        returns True if szip compression filter is available\n        ",
  "netCDF4._netCDF4.Dataset.has_zstd_filter": "**`has_zstd_filter(self)`**\n        returns True if zstd compression filter is available\n        ",
  "netCDF4._netCDF4.Dataset.isopen": "\n**`isopen(self)`**\n\nIs the Dataset open or closed?\n        ",
  "netCDF4._netCDF4.Dataset.name": "string name of Group instance",
  "netCDF4._netCDF4.Dataset.ncattrs": "\n**`ncattrs(self)`**\n\nreturn netCDF global attribute names for this `Dataset` or `Group` in a list.",
  "netCDF4._netCDF4.Dataset.renameAttribute": "\n**`renameAttribute(self, oldname, newname)`**\n\nrename a `Dataset` or `Group` attribute named `oldname` to `newname`.",
  "netCDF4._netCDF4.Dataset.renameDimension": "\n**`renameDimension(self, oldname, newname)`**\n\nrename a `Dimension` named `oldname` to `newname`.",
  "netCDF4._netCDF4.Dataset.renameGroup": "\n**`renameGroup(self, oldname, newname)`**\n\nrename a `Group` named `oldname` to `newname` (requires netcdf >= 4.3.1).",
  "netCDF4._netCDF4.Dataset.renameVariable": "\n**`renameVariable(self, oldname, newname)`**\n\nrename a `Variable` named `oldname` to `newname`",
  "netCDF4._netCDF4.Dataset.set_always_mask": "\n**`set_always_mask(self, True_or_False)`**\n\nCall `Variable.set_always_mask` for all variables contained in\nthis `Dataset` or `Group`, as well as for all\nvariables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic conversion of\nmasked arrays with no missing values to regular numpy arrays shall be\napplied for all variables. Default True. Set to False to restore the default behaviour\nin versions prior to 1.4.1 (numpy array returned unless missing values are present,\notherwise masked array returned).\n\n***Note***: Calling this function only affects existing\nvariables. Variables created after calling this function will follow\nthe default behaviour.\n        ",
  "netCDF4._netCDF4.Dataset.set_auto_chartostring": "\n**`set_auto_chartostring(self, True_or_False)`**\n\nCall `Variable.set_auto_chartostring` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic conversion of\nall character arrays <--> string arrays should be performed for\ncharacter variables (variables of type `NC_CHAR` or `S1`) with the\n`_Encoding` attribute set.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.Dataset.set_auto_mask": "\n**`set_auto_mask(self, True_or_False)`**\n\nCall `Variable.set_auto_mask` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups. Only affects\nVariables with primitive or enum types (not compound or vlen Variables).\n\n**`True_or_False`**: Boolean determining if automatic conversion to masked arrays\nshall be applied for all variables.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.Dataset.set_auto_maskandscale": "\n**`set_auto_maskandscale(self, True_or_False)`**\n\nCall `Variable.set_auto_maskandscale` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic conversion to masked arrays\nand variable scaling shall be applied for all variables.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.Dataset.set_auto_scale": "\n**`set_auto_scale(self, True_or_False)`**\n\nCall `Variable.set_auto_scale` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic variable scaling\nshall be applied for all variables.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.Dataset.set_fill_off": "\n**`set_fill_off(self)`**\n\nSets the fill mode for a `Dataset` open for writing to `off`.\n\nThis will prevent the data from being pre-filled with fill values, which\nmay result in some performance improvements. However, you must then make\nsure the data is actually written before being read.",
  "netCDF4._netCDF4.Dataset.set_fill_on": "\n**`set_fill_on(self)`**\n\nSets the fill mode for a `Dataset` open for writing to `on`.\n\nThis causes data to be pre-filled with fill values. The fill values can be\ncontrolled by the variable's `_Fill_Value` attribute, but is usually\nsufficient to the use the netCDF default `_Fill_Value` (defined\nseparately for each variable type). The default behavior of the netCDF\nlibrary corresponds to `set_fill_on`.  Data which are equal to the\n`_Fill_Value` indicate that the variable was created, but never written\nto.",
  "netCDF4._netCDF4.Dataset.set_ncstring_attrs": "\n**`set_ncstring_attrs(self, True_or_False)`**\n\nCall `Variable.set_ncstring_attrs` for all variables contained in\nthis `Dataset` or `Group`, as well as for all its\nsubgroups and their variables.\n\n**`True_or_False`**: Boolean determining if all string attributes are\ncreated as variable-length NC_STRINGs, (if True), or if ascii text\nattributes are stored as NC_CHARs (if False; default)\n\n***Note***: Calling this function only affects newly created attributes\nof existing (sub-) groups and their variables.\n        ",
  "netCDF4._netCDF4.Dataset.setncattr": "\n**`setncattr(self,name,value)`**\n\nset a netCDF dataset or group attribute using name,value pair.\nUse if you need to set a netCDF attribute with the\nwith the same name as one of the reserved python attributes.",
  "netCDF4._netCDF4.Dataset.setncattr_string": "\n**`setncattr_string(self,name,value)`**\n\nset a netCDF dataset or group string attribute using name,value pair.\nUse if you need to ensure that a netCDF attribute is created with type\n`NC_STRING` if the file format is `NETCDF4`.",
  "netCDF4._netCDF4.Dataset.setncatts": "\n**`setncatts(self,attdict)`**\n\nset a bunch of netCDF dataset or group attributes at once using a python dictionary.\nThis may be faster when setting a lot of attributes for a `NETCDF3`\nformatted file, since nc_redef/nc_enddef is not called in between setting\neach attribute",
  "netCDF4._netCDF4.Dataset.sync": "\n**`sync(self)`**\n\nWrites all buffered data in the `Dataset` to the disk file.",
  "netCDF4._netCDF4.Dataset.tocdl": "\n**`tocdl(self, coordvars=False, data=False, outfile=None)`**\n\ncall [ncdump][ncdump] via subprocess to create [CDL][cdl]\ntext representation of Dataset. Requires [ncdump][ncdump]\nto be installed and in `$PATH`.\n\n**`coordvars`**: include coordinate variable data (via `ncdump -c`). Default False\n\n**`data`**: if True, write out variable data (Default False).\n\n**`outfile`**: If not None, file to output ncdump to. Default is to return a string.\n\n[ncdump]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#ncdump_guide\n[cdl]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#cdl_guide\n        ",
  "netCDF4._netCDF4.Dimension": "\nA netCDF `Dimension` is used to describe the coordinates of a `Variable`.\nSee `Dimension.__init__` for more details.\n\nThe current maximum size of a `Dimension` instance can be obtained by\ncalling the python `len` function on the `Dimension` instance. The\n`Dimension.isunlimited` method of a `Dimension` instance can be used to\ndetermine if the dimension is unlimited.\n\nRead-only class variables:\n\n**`name`**: String name, used when creating a `Variable` with\n`Dataset.createVariable`.\n\n**`size`**: Current `Dimension` size (same as `len(d)`, where `d` is a\n`Dimension` instance).\n    ",
  "netCDF4._netCDF4.Dimension.__init__": "\n        **`__init__(self, group, name, size=None)`**\n\n        `Dimension` constructor.\n\n        **`group`**: `Group` instance to associate with dimension.\n\n        **`name`**: Name of the dimension.\n\n        **`size`**: Size of the dimension. `None` or 0 means unlimited. (Default `None`).\n\n        ***Note***: `Dimension` instances should be created using the\n        `Dataset.createDimension` method of a `Group` or\n        `Dataset` instance, not using `Dimension.__init__` directly.\n        ",
  "netCDF4._netCDF4.Dimension.__len__": "Return len(self).",
  "netCDF4._netCDF4.Dimension.__str__": "Return str(self).",
  "netCDF4._netCDF4.Dimension.group": "\n**`group(self)`**\n\nreturn the group that this `Dimension` is a member of.",
  "netCDF4._netCDF4.Dimension.isunlimited": "\n**`isunlimited(self)`**\n\nreturns `True` if the `Dimension` instance is unlimited, `False` otherwise.",
  "netCDF4._netCDF4.Dimension.name": "string name of Dimension instance",
  "netCDF4._netCDF4.Dimension.size": "current size of Dimension (calls `len` on Dimension instance)",
  "netCDF4._netCDF4.EnumType": "\nA `EnumType` instance is used to describe an Enum data\ntype, and can be passed to the the `Dataset.createVariable` method of\na `Dataset` or `Group` instance. See\n`EnumType.__init__` for more details.\n\nThe instance variables `dtype`, `name` and `enum_dict` should not be modified by\nthe user.\n    ",
  "netCDF4._netCDF4.EnumType.__init__": "\n        **`__init__(group, datatype, datatype_name, enum_dict)`**\n\n        EnumType constructor.\n\n        **`group`**: `Group` instance to associate with the VLEN datatype.\n\n        **`datatype`**: An numpy integer dtype object describing the base type\n        for the Enum.\n\n        **`datatype_name`**: a Python string containing a description of the\n        Enum data type.\n\n        **`enum_dict`**: a Python dictionary containing the Enum field/value\n        pairs.\n\n        ***`Note`***: `EnumType` instances should be created using the\n        `Dataset.createEnumType` method of a `Dataset` or\n        `Group` instance, not using this class directly.\n        ",
  "netCDF4._netCDF4.EnumType.__str__": "Return str(self).",
  "netCDF4._netCDF4.Group": "\nGroups define a hierarchical namespace within a netCDF file. They are\nanalogous to directories in a unix filesystem. Each `Group` behaves like\na `Dataset` within a Dataset, and can contain it's own variables,\ndimensions and attributes (and other Groups). See `Group.__init__`\nfor more details.\n\n`Group` inherits from `Dataset`, so all the\n`Dataset` class methods and variables are available\nto a `Group` instance (except the `close` method).\n\nAdditional read-only class variables:\n\n**`name`**: String describing the group name.\n    ",
  "netCDF4._netCDF4.Group.__delattr__": "Implement delattr(self, name).",
  "netCDF4._netCDF4.Group.__getattribute__": "Return getattr(self, name).",
  "netCDF4._netCDF4.Group.__getitem__": "Return self[key].",
  "netCDF4._netCDF4.Group.__init__": "\n        **`__init__(self, parent, name)`**\n        `Group` constructor.\n\n        **`parent`**: `Group` instance for the parent group.  If being created\n        in the root group, use a `Dataset` instance.\n\n        **`name`**: - Name of the group.\n\n        ***Note***: `Group` instances should be created using the\n        `Dataset.createGroup` method of a `Dataset` instance, or\n        another `Group` instance, not using this class directly.\n        ",
  "netCDF4._netCDF4.Group.__setattr__": "Implement setattr(self, name, value).",
  "netCDF4._netCDF4.Group.__str__": "Return str(self).",
  "netCDF4._netCDF4.Group.close": "\n**`close(self)`**\n\noverrides `Dataset` close method which does not apply to `Group`\ninstances, raises OSError.",
  "netCDF4._netCDF4.Group.createCompoundType": "\n**`createCompoundType(self, datatype, datatype_name)`**\n\nCreates a new compound data type named `datatype_name` from the numpy\ndtype object `datatype`.\n\n***Note***: If the new compound data type contains other compound data types\n(i.e. it is a 'nested' compound type, where not all of the elements\nare homogeneous numeric data types), then the 'inner' compound types **must** be\ncreated first.\n\nThe return value is the `CompoundType` class instance describing the new\ndatatype.",
  "netCDF4._netCDF4.Group.createDimension": "\n**`createDimension(self, dimname, size=None)`**\n\nCreates a new dimension with the given `dimname` and `size`.\n\n`size` must be a positive integer or `None`, which stands for\n\"unlimited\" (default is `None`). Specifying a size of 0 also\nresults in an unlimited dimension. The return value is the `Dimension`\nclass instance describing the new dimension.  To determine the current\nmaximum size of the dimension, use the `len` function on the `Dimension`\ninstance. To determine if a dimension is 'unlimited', use the\n`Dimension.isunlimited` method of the `Dimension` instance.",
  "netCDF4._netCDF4.Group.createEnumType": "\n**`createEnumType(self, datatype, datatype_name, enum_dict)`**\n\nCreates a new Enum data type named `datatype_name` from a numpy\ninteger dtype object `datatype`, and a python dictionary\ndefining the enum fields and values.\n\nThe return value is the `EnumType` class instance describing the new\ndatatype.",
  "netCDF4._netCDF4.Group.createGroup": "\n**`createGroup(self, groupname)`**\n\nCreates a new `Group` with the given `groupname`.\n\nIf `groupname` is specified as a path, using forward slashes as in unix to\nseparate components, then intermediate groups will be created as necessary\n(analogous to `mkdir -p` in unix).  For example,\n`createGroup('/GroupA/GroupB/GroupC')` will create `GroupA`,\n`GroupA/GroupB`, and `GroupA/GroupB/GroupC`, if they don't already exist.\nIf the specified path describes a group that already exists, no error is\nraised.\n\nThe return value is a `Group` class instance.",
  "netCDF4._netCDF4.Group.createVLType": "\n**`createVLType(self, datatype, datatype_name)`**\n\nCreates a new VLEN data type named `datatype_name` from a numpy\ndtype object `datatype`.\n\nThe return value is the `VLType` class instance describing the new\ndatatype.",
  "netCDF4._netCDF4.Group.createVariable": "\n**`createVariable(self, varname, datatype, dimensions=(), compression=None, zlib=False,\ncomplevel=4, shuffle=True, fletcher32=False, contiguous=False, chunksizes=None,\nszip_coding='nn', szip_pixels_per_block=8, blosc_shuffle=1,\nendian='native', least_significant_digit=None, significant_digits=None, quantize_mode='BitGroom',\nfill_value=None, chunk_cache=None)`**\n\nCreates a new variable with the given `varname`, `datatype`, and\n`dimensions`. If dimensions are not given, the variable is assumed to be\na scalar.\n\nIf `varname` is specified as a path, using forward slashes as in unix to\nseparate components, then intermediate groups will be created as necessary\nFor example, `createVariable('/GroupA/GroupB/VarC', float, ('x','y'))` will create groups `GroupA`\nand `GroupA/GroupB`, plus the variable `GroupA/GroupB/VarC`, if the preceding\ngroups don't already exist.\n\nThe `datatype` can be a numpy datatype object, or a string that describes\na numpy dtype object (like the `dtype.str` attribute of a numpy array).\nSupported specifiers include: `'S1' or 'c' (NC_CHAR), 'i1' or 'b' or 'B'\n(NC_BYTE), 'u1' (NC_UBYTE), 'i2' or 'h' or 's' (NC_SHORT), 'u2'\n(NC_USHORT), 'i4' or 'i' or 'l' (NC_INT), 'u4' (NC_UINT), 'i8' (NC_INT64),\n'u8' (NC_UINT64), 'f4' or 'f' (NC_FLOAT), 'f8' or 'd' (NC_DOUBLE)`.\n`datatype` can also be a `CompoundType` instance\n(for a structured, or compound array), a `VLType` instance\n(for a variable-length array), or the python `str` builtin\n(for a variable-length string array). Numpy string and unicode datatypes with\nlength greater than one are aliases for `str`.\n\nData from netCDF variables is presented to python as numpy arrays with\nthe corresponding data type.\n\n`dimensions` must be a tuple containing `Dimension` instances and/or\ndimension names (strings) that have been defined\npreviously using `Dataset.createDimension`. The default value\nis an empty tuple, which means the variable is a scalar.\n\nIf the optional keyword argument `compression` is set, the data will be\ncompressed in the netCDF file using the specified compression algorithm.\nCurrently `zlib`,`szip`,`zstd`,`bzip2`,`blosc_lz`,`blosc_lz4`,`blosc_lz4hc`,\n`blosc_zlib` and `blosc_zstd` are supported.\nDefault is `None` (no compression).  All of the compressors except\n`zlib` and `szip` use the HDF5 plugin architecture.\n\nIf the optional keyword `zlib` is `True`, the data will be compressed in\nthe netCDF file using zlib compression (default `False`).  The use of this option is\ndeprecated in favor of `compression='zlib'`.\n\nThe optional keyword `complevel` is an integer between 0 and 9 describing\nthe level of compression desired (default 4). Ignored if `compression=None`.\nA value of zero disables compression.\n\nIf the optional keyword `shuffle` is `True`, the HDF5 shuffle filter\nwill be applied before compressing the data with zlib (default `True`).  This\nsignificantly improves compression. Default is `True`. Ignored if\n`zlib=False`.\n\nThe optional kwarg `blosc_shuffle`is  ignored\nunless the blosc compressor is used. `blosc_shuffle` can be 0 (no shuffle),\n1 (byte-wise shuffle) or 2 (bit-wise shuffle). Default is 1.\n\nThe optional kwargs `szip_coding` and `szip_pixels_per_block` are ignored\nunless the szip compressor is used. `szip_coding` can be `ec` (entropy coding)\nor `nn` (nearest neighbor coding). Default is `nn`. `szip_pixels_per_block`\ncan be 4, 8, 16 or 32 (default 8).\n\nIf the optional keyword `fletcher32` is `True`, the Fletcher32 HDF5\nchecksum algorithm is activated to detect errors. Default `False`.\n\nIf the optional keyword `contiguous` is `True`, the variable data is\nstored contiguously on disk.  Default `False`. Setting to `True` for\na variable with an unlimited dimension will trigger an error.\nFixed size variables (with no unlimited dimension) with no compression filters\nare contiguous by default.\n\nThe optional keyword `chunksizes` can be used to manually specify the\nHDF5 chunksizes for each dimension of the variable.\nA detailed discussion of HDF chunking and I/O performance is available\n[here](https://support.hdfgroup.org/HDF5/doc/Advanced/Chunking).\nThe default chunking scheme in the netcdf-c library is discussed\n[here](https://www.unidata.ucar.edu/software/netcdf/documentation/NUG/netcdf_perf_chunking.html).\nBasically, you want the chunk size for each dimension to match as\nclosely as possible the size of the data block that users will read\nfrom the file. `chunksizes` cannot be set if `contiguous=True`.\n\nThe optional keyword `endian` can be used to control whether the\ndata is stored in little or big endian format on disk. Possible\nvalues are `little, big` or `native` (default). The library\nwill automatically handle endian conversions when the data is read,\nbut if the data is always going to be read on a computer with the\nopposite format as the one used to create the file, there may be\nsome performance advantage to be gained by setting the endian-ness.\n\nThe optional keyword `fill_value` can be used to override the default\nnetCDF `_FillValue` (the value that the variable gets filled with before\nany data is written to it, defaults given in the dict `netCDF4.default_fillvals`).\nIf fill_value is set to `False`, then the variable is not pre-filled.\n\nIf the optional keyword parameters `least_significant_digit` or `significant_digits` are\nspecified, variable data will be truncated (quantized). In conjunction\nwith `compression='zlib'` this produces 'lossy', but significantly more\nefficient compression. For example, if `least_significant_digit=1`,\ndata will be quantized using `numpy.around(scale*data)/scale`, where\nscale = 2**bits, and bits is determined so that a precision of 0.1 is\nretained (in this case bits=4). From the\n[PSL metadata conventions](http://www.esrl.noaa.gov/psl/data/gridded/conventions/cdc_netcdf_standard.shtml):\n\"least_significant_digit -- power of ten of the smallest decimal place\nin unpacked data that is a reliable value.\" Default is `None`, or no\nquantization, or 'lossless' compression.  If `significant_digits=3`\nthen the data will be quantized so that three significant digits are retained, independent\nof the floating point exponent. The keyword argument `quantize_mode` controls\nthe quantization algorithm (default 'BitGroom', 'BitRound' and\n'GranularBitRound' also available).  The 'GranularBitRound'\nalgorithm may result in better compression for typical geophysical datasets.\nThis `significant_digits` kwarg is only available  with netcdf-c >= 4.9.0, and\nonly works with `NETCDF4` or `NETCDF4_CLASSIC` formatted files.\n\nWhen creating variables in a `NETCDF4` or `NETCDF4_CLASSIC` formatted file,\nHDF5 creates something called a 'chunk cache' for each variable.  The\ndefault size of the chunk cache may be large enough to completely fill\navailable memory when creating thousands of variables.  The optional\nkeyword `chunk_cache` allows you to reduce (or increase) the size of\nthe default chunk cache when creating a variable.  The setting only\npersists as long as the Dataset is open - you can use the set_var_chunk_cache\nmethod to change it the next time the Dataset is opened.\nWarning - messing with this parameter can seriously degrade performance.\n\nThe return value is the `Variable` class instance describing the new\nvariable.\n\nA list of names corresponding to netCDF variable attributes can be\nobtained with the `Variable` method `Variable.ncattrs`. A dictionary\ncontaining all the netCDF attribute name/value pairs is provided by\nthe `__dict__` attribute of a `Variable` instance.\n\n`Variable` instances behave much like array objects. Data can be\nassigned to or retrieved from a variable with indexing and slicing\noperations on the `Variable` instance. A `Variable` instance has six\nDataset standard attributes: `dimensions, dtype, shape, ndim, name` and\n`least_significant_digit`. Application programs should never modify\nthese attributes. The `dimensions` attribute is a tuple containing the\nnames of the dimensions associated with this variable. The `dtype`\nattribute is a string describing the variable's data type (`i4, f8,\nS1,` etc). The `shape` attribute is a tuple describing the current\nsizes of all the variable's dimensions. The `name` attribute is a\nstring containing the name of the Variable instance.\nThe `least_significant_digit`\nattributes describes the power of ten of the smallest decimal place in\nthe data the contains a reliable value.  assigned to the `Variable`\ninstance. The `ndim` attribute\nis the number of variable dimensions.",
  "netCDF4._netCDF4.Group.delncattr": "\n**`delncattr(self,name,value)`**\n\ndelete a netCDF dataset or group attribute.  Use if you need to delete a\nnetCDF attribute with the same name as one of the reserved python\nattributes.",
  "netCDF4._netCDF4.Group.filepath": "**`filepath(self,encoding=None)`**\n\n        Get the file system path (or the opendap URL) which was used to\n        open/create the Dataset. Requires netcdf >= 4.1.2.  The path\n        is decoded into a string using `sys.getfilesystemencoding()` by default, this can be\n        changed using the `encoding` kwarg.\n        ",
  "netCDF4._netCDF4.Group.fromcdl": "\n**`fromcdl(cdlfilename, ncfilename=None, mode='a',format='NETCDF4')`**\n\ncall [ncgen][ncgen] via subprocess to create Dataset from [CDL][cdl]\ntext representation. Requires [ncgen][ncgen] to be installed and in `$PATH`.\n\n**`cdlfilename`**:  CDL file.\n\n**`ncfilename`**: netCDF file to create. If not given, CDL filename with\nsuffix replaced by `.nc` is used..\n\n**`mode`**:  Access mode to open Dataset (Default `'a'`).\n\n**`format`**: underlying file format to use (one of `'NETCDF4',\n'NETCDF4_CLASSIC', 'NETCDF3_CLASSIC'`, `'NETCDF3_64BIT_OFFSET'` or\n`'NETCDF3_64BIT_DATA'`. Default `'NETCDF4'`.\n\nDataset instance for `ncfilename` is returned.\n\n[ncgen]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#ncgen_guide\n[cdl]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#cdl_guide\n        ",
  "netCDF4._netCDF4.Group.get_variables_by_attributes": "\n**`get_variables_by_attributes(self, **kwargs)`**\n\nReturns a list of variables that match specific conditions.\n\nCan pass in key=value parameters and variables are returned that\ncontain all of the matches. For example,\n\n```python\n>>> # Get variables with x-axis attribute.\n>>> vs = nc.get_variables_by_attributes(axis='X')\n>>> # Get variables with matching \"standard_name\" attribute\n>>> vs = nc.get_variables_by_attributes(standard_name='northward_sea_water_velocity')\n```\n\nCan pass in key=callable parameter and variables are returned if the\ncallable returns True.  The callable should accept a single parameter,\nthe attribute value.  None is given as the attribute value when the\nattribute does not exist on the variable. For example,\n\n```python\n>>> # Get Axis variables\n>>> vs = nc.get_variables_by_attributes(axis=lambda v: v in ['X', 'Y', 'Z', 'T'])\n>>> # Get variables that don't have an \"axis\" attribute\n>>> vs = nc.get_variables_by_attributes(axis=lambda v: v is None)\n>>> # Get variables that have a \"grid_mapping\" attribute\n>>> vs = nc.get_variables_by_attributes(grid_mapping=lambda v: v is not None)\n```\n",
  "netCDF4._netCDF4.Group.getncattr": "\n**`getncattr(self,name)`**\n\nretrieve a netCDF dataset or group attribute.\nUse if you need to get a netCDF attribute with the same\nname as one of the reserved python attributes.\n\noption kwarg `encoding` can be used to specify the\ncharacter encoding of a string attribute (default is `utf-8`).",
  "netCDF4._netCDF4.Group.has_blosc_filter": "**`has_blosc_filter(self)`**\n        returns True if blosc compression filter is available\n        ",
  "netCDF4._netCDF4.Group.has_bzip2_filter": "**`has_bzip2_filter(self)`**\n        returns True if bzip2 compression filter is available\n        ",
  "netCDF4._netCDF4.Group.has_szip_filter": "**`has_szip_filter(self)`**\n        returns True if szip compression filter is available\n        ",
  "netCDF4._netCDF4.Group.has_zstd_filter": "**`has_zstd_filter(self)`**\n        returns True if zstd compression filter is available\n        ",
  "netCDF4._netCDF4.Group.isopen": "\n**`isopen(self)`**\n\nIs the Dataset open or closed?\n        ",
  "netCDF4._netCDF4.Group.name": "string name of Group instance",
  "netCDF4._netCDF4.Group.ncattrs": "\n**`ncattrs(self)`**\n\nreturn netCDF global attribute names for this `Dataset` or `Group` in a list.",
  "netCDF4._netCDF4.Group.renameAttribute": "\n**`renameAttribute(self, oldname, newname)`**\n\nrename a `Dataset` or `Group` attribute named `oldname` to `newname`.",
  "netCDF4._netCDF4.Group.renameDimension": "\n**`renameDimension(self, oldname, newname)`**\n\nrename a `Dimension` named `oldname` to `newname`.",
  "netCDF4._netCDF4.Group.renameGroup": "\n**`renameGroup(self, oldname, newname)`**\n\nrename a `Group` named `oldname` to `newname` (requires netcdf >= 4.3.1).",
  "netCDF4._netCDF4.Group.renameVariable": "\n**`renameVariable(self, oldname, newname)`**\n\nrename a `Variable` named `oldname` to `newname`",
  "netCDF4._netCDF4.Group.set_always_mask": "\n**`set_always_mask(self, True_or_False)`**\n\nCall `Variable.set_always_mask` for all variables contained in\nthis `Dataset` or `Group`, as well as for all\nvariables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic conversion of\nmasked arrays with no missing values to regular numpy arrays shall be\napplied for all variables. Default True. Set to False to restore the default behaviour\nin versions prior to 1.4.1 (numpy array returned unless missing values are present,\notherwise masked array returned).\n\n***Note***: Calling this function only affects existing\nvariables. Variables created after calling this function will follow\nthe default behaviour.\n        ",
  "netCDF4._netCDF4.Group.set_auto_chartostring": "\n**`set_auto_chartostring(self, True_or_False)`**\n\nCall `Variable.set_auto_chartostring` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic conversion of\nall character arrays <--> string arrays should be performed for\ncharacter variables (variables of type `NC_CHAR` or `S1`) with the\n`_Encoding` attribute set.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.Group.set_auto_mask": "\n**`set_auto_mask(self, True_or_False)`**\n\nCall `Variable.set_auto_mask` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups. Only affects\nVariables with primitive or enum types (not compound or vlen Variables).\n\n**`True_or_False`**: Boolean determining if automatic conversion to masked arrays\nshall be applied for all variables.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.Group.set_auto_maskandscale": "\n**`set_auto_maskandscale(self, True_or_False)`**\n\nCall `Variable.set_auto_maskandscale` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic conversion to masked arrays\nand variable scaling shall be applied for all variables.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.Group.set_auto_scale": "\n**`set_auto_scale(self, True_or_False)`**\n\nCall `Variable.set_auto_scale` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic variable scaling\nshall be applied for all variables.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.Group.set_fill_off": "\n**`set_fill_off(self)`**\n\nSets the fill mode for a `Dataset` open for writing to `off`.\n\nThis will prevent the data from being pre-filled with fill values, which\nmay result in some performance improvements. However, you must then make\nsure the data is actually written before being read.",
  "netCDF4._netCDF4.Group.set_fill_on": "\n**`set_fill_on(self)`**\n\nSets the fill mode for a `Dataset` open for writing to `on`.\n\nThis causes data to be pre-filled with fill values. The fill values can be\ncontrolled by the variable's `_Fill_Value` attribute, but is usually\nsufficient to the use the netCDF default `_Fill_Value` (defined\nseparately for each variable type). The default behavior of the netCDF\nlibrary corresponds to `set_fill_on`.  Data which are equal to the\n`_Fill_Value` indicate that the variable was created, but never written\nto.",
  "netCDF4._netCDF4.Group.set_ncstring_attrs": "\n**`set_ncstring_attrs(self, True_or_False)`**\n\nCall `Variable.set_ncstring_attrs` for all variables contained in\nthis `Dataset` or `Group`, as well as for all its\nsubgroups and their variables.\n\n**`True_or_False`**: Boolean determining if all string attributes are\ncreated as variable-length NC_STRINGs, (if True), or if ascii text\nattributes are stored as NC_CHARs (if False; default)\n\n***Note***: Calling this function only affects newly created attributes\nof existing (sub-) groups and their variables.\n        ",
  "netCDF4._netCDF4.Group.setncattr": "\n**`setncattr(self,name,value)`**\n\nset a netCDF dataset or group attribute using name,value pair.\nUse if you need to set a netCDF attribute with the\nwith the same name as one of the reserved python attributes.",
  "netCDF4._netCDF4.Group.setncattr_string": "\n**`setncattr_string(self,name,value)`**\n\nset a netCDF dataset or group string attribute using name,value pair.\nUse if you need to ensure that a netCDF attribute is created with type\n`NC_STRING` if the file format is `NETCDF4`.",
  "netCDF4._netCDF4.Group.setncatts": "\n**`setncatts(self,attdict)`**\n\nset a bunch of netCDF dataset or group attributes at once using a python dictionary.\nThis may be faster when setting a lot of attributes for a `NETCDF3`\nformatted file, since nc_redef/nc_enddef is not called in between setting\neach attribute",
  "netCDF4._netCDF4.Group.sync": "\n**`sync(self)`**\n\nWrites all buffered data in the `Dataset` to the disk file.",
  "netCDF4._netCDF4.Group.tocdl": "\n**`tocdl(self, coordvars=False, data=False, outfile=None)`**\n\ncall [ncdump][ncdump] via subprocess to create [CDL][cdl]\ntext representation of Dataset. Requires [ncdump][ncdump]\nto be installed and in `$PATH`.\n\n**`coordvars`**: include coordinate variable data (via `ncdump -c`). Default False\n\n**`data`**: if True, write out variable data (Default False).\n\n**`outfile`**: If not None, file to output ncdump to. Default is to return a string.\n\n[ncdump]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#ncdump_guide\n[cdl]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#cdl_guide\n        ",
  "netCDF4._netCDF4.MFDataset": "\nClass for reading multi-file netCDF Datasets, making variables\nspanning multiple files appear as if they were in one file.\nDatasets must be in `NETCDF4_CLASSIC, NETCDF3_CLASSIC, NETCDF3_64BIT_OFFSET\nor NETCDF3_64BIT_DATA` format (`NETCDF4` Datasets won't work).\n\nAdapted from [pycdf](http://pysclint.sourceforge.net/pycdf) by Andre Gosselin.\n\nExample usage (See `MFDataset.__init__` for more details):\n\n```python\n>>> import numpy as np\n>>> # create a series of netCDF files with a variable sharing\n>>> # the same unlimited dimension.\n>>> for nf in range(10):\n...     with Dataset(\"mftest%s.nc\" % nf, \"w\", format='NETCDF4_CLASSIC') as f:\n...         f.createDimension(\"x\",None)\n...         x = f.createVariable(\"x\",\"i\",(\"x\",))\n...         x[0:10] = np.arange(nf*10,10*(nf+1))\n>>> # now read all those files in at once, in one Dataset.\n>>> f = MFDataset(\"mftest*nc\")\n>>> print(f.variables[\"x\"][:])\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\n 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47\n 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71\n 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95\n 96 97 98 99]\n```\n    ",
  "netCDF4._netCDF4.MFDataset.__delattr__": "Implement delattr(self, name).",
  "netCDF4._netCDF4.MFDataset.__getitem__": "Return self[key].",
  "netCDF4._netCDF4.MFDataset.__init__": "\n        **`__init__(self, files, check=False, aggdim=None, exclude=[],\n        master_file=None)`**\n\n        Open a Dataset spanning multiple files, making it look as if it was a\n        single file. Variables in the list of files that share the same\n        dimension (specified with the keyword `aggdim`) are aggregated. If\n        `aggdim` is not specified, the unlimited is aggregated.  Currently,\n        `aggdim` must be the leftmost (slowest varying) dimension of each\n        of the variables to be aggregated.\n\n        **`files`**: either a sequence of netCDF files or a string with a\n        wildcard (converted to a sorted list of files using glob)  If\n        the `master_file` kwarg is not specified, the first file\n        in the list will become the \"master\" file, defining all the\n        variables with an aggregation dimension which may span\n        subsequent files. Attribute access returns attributes only from \"master\"\n        file. The files are always opened in read-only mode.\n\n        **`check`**: True if you want to do consistency checking to ensure the\n        correct variables structure for all of the netcdf files.  Checking makes\n        the initialization of the MFDataset instance much slower. Default is\n        False.\n\n        **`aggdim`**: The name of the dimension to aggregate over (must\n        be the leftmost dimension of each of the variables to be aggregated).\n        If None (default), aggregate over the unlimited dimension.\n\n        **`exclude`**: A list of variable names to exclude from aggregation.\n        Default is an empty list.\n\n        **`master_file`**: file to use as \"master file\", defining all the\n        variables with an aggregation dimension and all global attributes.\n       ",
  "netCDF4._netCDF4.MFDataset.__setattr__": "override base class attribute creation",
  "netCDF4._netCDF4.MFDataset.__str__": "Return str(self).",
  "netCDF4._netCDF4.MFDataset.close": "\n        **`close(self)`**\n\n        close all the open files.\n        ",
  "netCDF4._netCDF4.MFDataset.createCompoundType": "\n**`createCompoundType(self, datatype, datatype_name)`**\n\nCreates a new compound data type named `datatype_name` from the numpy\ndtype object `datatype`.\n\n***Note***: If the new compound data type contains other compound data types\n(i.e. it is a 'nested' compound type, where not all of the elements\nare homogeneous numeric data types), then the 'inner' compound types **must** be\ncreated first.\n\nThe return value is the `CompoundType` class instance describing the new\ndatatype.",
  "netCDF4._netCDF4.MFDataset.createDimension": "\n**`createDimension(self, dimname, size=None)`**\n\nCreates a new dimension with the given `dimname` and `size`.\n\n`size` must be a positive integer or `None`, which stands for\n\"unlimited\" (default is `None`). Specifying a size of 0 also\nresults in an unlimited dimension. The return value is the `Dimension`\nclass instance describing the new dimension.  To determine the current\nmaximum size of the dimension, use the `len` function on the `Dimension`\ninstance. To determine if a dimension is 'unlimited', use the\n`Dimension.isunlimited` method of the `Dimension` instance.",
  "netCDF4._netCDF4.MFDataset.createEnumType": "\n**`createEnumType(self, datatype, datatype_name, enum_dict)`**\n\nCreates a new Enum data type named `datatype_name` from a numpy\ninteger dtype object `datatype`, and a python dictionary\ndefining the enum fields and values.\n\nThe return value is the `EnumType` class instance describing the new\ndatatype.",
  "netCDF4._netCDF4.MFDataset.createGroup": "\n**`createGroup(self, groupname)`**\n\nCreates a new `Group` with the given `groupname`.\n\nIf `groupname` is specified as a path, using forward slashes as in unix to\nseparate components, then intermediate groups will be created as necessary\n(analogous to `mkdir -p` in unix).  For example,\n`createGroup('/GroupA/GroupB/GroupC')` will create `GroupA`,\n`GroupA/GroupB`, and `GroupA/GroupB/GroupC`, if they don't already exist.\nIf the specified path describes a group that already exists, no error is\nraised.\n\nThe return value is a `Group` class instance.",
  "netCDF4._netCDF4.MFDataset.createVLType": "\n**`createVLType(self, datatype, datatype_name)`**\n\nCreates a new VLEN data type named `datatype_name` from a numpy\ndtype object `datatype`.\n\nThe return value is the `VLType` class instance describing the new\ndatatype.",
  "netCDF4._netCDF4.MFDataset.createVariable": "\n**`createVariable(self, varname, datatype, dimensions=(), compression=None, zlib=False,\ncomplevel=4, shuffle=True, fletcher32=False, contiguous=False, chunksizes=None,\nszip_coding='nn', szip_pixels_per_block=8, blosc_shuffle=1,\nendian='native', least_significant_digit=None, significant_digits=None, quantize_mode='BitGroom',\nfill_value=None, chunk_cache=None)`**\n\nCreates a new variable with the given `varname`, `datatype`, and\n`dimensions`. If dimensions are not given, the variable is assumed to be\na scalar.\n\nIf `varname` is specified as a path, using forward slashes as in unix to\nseparate components, then intermediate groups will be created as necessary\nFor example, `createVariable('/GroupA/GroupB/VarC', float, ('x','y'))` will create groups `GroupA`\nand `GroupA/GroupB`, plus the variable `GroupA/GroupB/VarC`, if the preceding\ngroups don't already exist.\n\nThe `datatype` can be a numpy datatype object, or a string that describes\na numpy dtype object (like the `dtype.str` attribute of a numpy array).\nSupported specifiers include: `'S1' or 'c' (NC_CHAR), 'i1' or 'b' or 'B'\n(NC_BYTE), 'u1' (NC_UBYTE), 'i2' or 'h' or 's' (NC_SHORT), 'u2'\n(NC_USHORT), 'i4' or 'i' or 'l' (NC_INT), 'u4' (NC_UINT), 'i8' (NC_INT64),\n'u8' (NC_UINT64), 'f4' or 'f' (NC_FLOAT), 'f8' or 'd' (NC_DOUBLE)`.\n`datatype` can also be a `CompoundType` instance\n(for a structured, or compound array), a `VLType` instance\n(for a variable-length array), or the python `str` builtin\n(for a variable-length string array). Numpy string and unicode datatypes with\nlength greater than one are aliases for `str`.\n\nData from netCDF variables is presented to python as numpy arrays with\nthe corresponding data type.\n\n`dimensions` must be a tuple containing `Dimension` instances and/or\ndimension names (strings) that have been defined\npreviously using `Dataset.createDimension`. The default value\nis an empty tuple, which means the variable is a scalar.\n\nIf the optional keyword argument `compression` is set, the data will be\ncompressed in the netCDF file using the specified compression algorithm.\nCurrently `zlib`,`szip`,`zstd`,`bzip2`,`blosc_lz`,`blosc_lz4`,`blosc_lz4hc`,\n`blosc_zlib` and `blosc_zstd` are supported.\nDefault is `None` (no compression).  All of the compressors except\n`zlib` and `szip` use the HDF5 plugin architecture.\n\nIf the optional keyword `zlib` is `True`, the data will be compressed in\nthe netCDF file using zlib compression (default `False`).  The use of this option is\ndeprecated in favor of `compression='zlib'`.\n\nThe optional keyword `complevel` is an integer between 0 and 9 describing\nthe level of compression desired (default 4). Ignored if `compression=None`.\nA value of zero disables compression.\n\nIf the optional keyword `shuffle` is `True`, the HDF5 shuffle filter\nwill be applied before compressing the data with zlib (default `True`).  This\nsignificantly improves compression. Default is `True`. Ignored if\n`zlib=False`.\n\nThe optional kwarg `blosc_shuffle`is  ignored\nunless the blosc compressor is used. `blosc_shuffle` can be 0 (no shuffle),\n1 (byte-wise shuffle) or 2 (bit-wise shuffle). Default is 1.\n\nThe optional kwargs `szip_coding` and `szip_pixels_per_block` are ignored\nunless the szip compressor is used. `szip_coding` can be `ec` (entropy coding)\nor `nn` (nearest neighbor coding). Default is `nn`. `szip_pixels_per_block`\ncan be 4, 8, 16 or 32 (default 8).\n\nIf the optional keyword `fletcher32` is `True`, the Fletcher32 HDF5\nchecksum algorithm is activated to detect errors. Default `False`.\n\nIf the optional keyword `contiguous` is `True`, the variable data is\nstored contiguously on disk.  Default `False`. Setting to `True` for\na variable with an unlimited dimension will trigger an error.\nFixed size variables (with no unlimited dimension) with no compression filters\nare contiguous by default.\n\nThe optional keyword `chunksizes` can be used to manually specify the\nHDF5 chunksizes for each dimension of the variable.\nA detailed discussion of HDF chunking and I/O performance is available\n[here](https://support.hdfgroup.org/HDF5/doc/Advanced/Chunking).\nThe default chunking scheme in the netcdf-c library is discussed\n[here](https://www.unidata.ucar.edu/software/netcdf/documentation/NUG/netcdf_perf_chunking.html).\nBasically, you want the chunk size for each dimension to match as\nclosely as possible the size of the data block that users will read\nfrom the file. `chunksizes` cannot be set if `contiguous=True`.\n\nThe optional keyword `endian` can be used to control whether the\ndata is stored in little or big endian format on disk. Possible\nvalues are `little, big` or `native` (default). The library\nwill automatically handle endian conversions when the data is read,\nbut if the data is always going to be read on a computer with the\nopposite format as the one used to create the file, there may be\nsome performance advantage to be gained by setting the endian-ness.\n\nThe optional keyword `fill_value` can be used to override the default\nnetCDF `_FillValue` (the value that the variable gets filled with before\nany data is written to it, defaults given in the dict `netCDF4.default_fillvals`).\nIf fill_value is set to `False`, then the variable is not pre-filled.\n\nIf the optional keyword parameters `least_significant_digit` or `significant_digits` are\nspecified, variable data will be truncated (quantized). In conjunction\nwith `compression='zlib'` this produces 'lossy', but significantly more\nefficient compression. For example, if `least_significant_digit=1`,\ndata will be quantized using `numpy.around(scale*data)/scale`, where\nscale = 2**bits, and bits is determined so that a precision of 0.1 is\nretained (in this case bits=4). From the\n[PSL metadata conventions](http://www.esrl.noaa.gov/psl/data/gridded/conventions/cdc_netcdf_standard.shtml):\n\"least_significant_digit -- power of ten of the smallest decimal place\nin unpacked data that is a reliable value.\" Default is `None`, or no\nquantization, or 'lossless' compression.  If `significant_digits=3`\nthen the data will be quantized so that three significant digits are retained, independent\nof the floating point exponent. The keyword argument `quantize_mode` controls\nthe quantization algorithm (default 'BitGroom', 'BitRound' and\n'GranularBitRound' also available).  The 'GranularBitRound'\nalgorithm may result in better compression for typical geophysical datasets.\nThis `significant_digits` kwarg is only available  with netcdf-c >= 4.9.0, and\nonly works with `NETCDF4` or `NETCDF4_CLASSIC` formatted files.\n\nWhen creating variables in a `NETCDF4` or `NETCDF4_CLASSIC` formatted file,\nHDF5 creates something called a 'chunk cache' for each variable.  The\ndefault size of the chunk cache may be large enough to completely fill\navailable memory when creating thousands of variables.  The optional\nkeyword `chunk_cache` allows you to reduce (or increase) the size of\nthe default chunk cache when creating a variable.  The setting only\npersists as long as the Dataset is open - you can use the set_var_chunk_cache\nmethod to change it the next time the Dataset is opened.\nWarning - messing with this parameter can seriously degrade performance.\n\nThe return value is the `Variable` class instance describing the new\nvariable.\n\nA list of names corresponding to netCDF variable attributes can be\nobtained with the `Variable` method `Variable.ncattrs`. A dictionary\ncontaining all the netCDF attribute name/value pairs is provided by\nthe `__dict__` attribute of a `Variable` instance.\n\n`Variable` instances behave much like array objects. Data can be\nassigned to or retrieved from a variable with indexing and slicing\noperations on the `Variable` instance. A `Variable` instance has six\nDataset standard attributes: `dimensions, dtype, shape, ndim, name` and\n`least_significant_digit`. Application programs should never modify\nthese attributes. The `dimensions` attribute is a tuple containing the\nnames of the dimensions associated with this variable. The `dtype`\nattribute is a string describing the variable's data type (`i4, f8,\nS1,` etc). The `shape` attribute is a tuple describing the current\nsizes of all the variable's dimensions. The `name` attribute is a\nstring containing the name of the Variable instance.\nThe `least_significant_digit`\nattributes describes the power of ten of the smallest decimal place in\nthe data the contains a reliable value.  assigned to the `Variable`\ninstance. The `ndim` attribute\nis the number of variable dimensions.",
  "netCDF4._netCDF4.MFDataset.delncattr": "\n**`delncattr(self,name,value)`**\n\ndelete a netCDF dataset or group attribute.  Use if you need to delete a\nnetCDF attribute with the same name as one of the reserved python\nattributes.",
  "netCDF4._netCDF4.MFDataset.filepath": "**`filepath(self,encoding=None)`**\n\n        Get the file system path (or the opendap URL) which was used to\n        open/create the Dataset. Requires netcdf >= 4.1.2.  The path\n        is decoded into a string using `sys.getfilesystemencoding()` by default, this can be\n        changed using the `encoding` kwarg.\n        ",
  "netCDF4._netCDF4.MFDataset.fromcdl": "\n**`fromcdl(cdlfilename, ncfilename=None, mode='a',format='NETCDF4')`**\n\ncall [ncgen][ncgen] via subprocess to create Dataset from [CDL][cdl]\ntext representation. Requires [ncgen][ncgen] to be installed and in `$PATH`.\n\n**`cdlfilename`**:  CDL file.\n\n**`ncfilename`**: netCDF file to create. If not given, CDL filename with\nsuffix replaced by `.nc` is used..\n\n**`mode`**:  Access mode to open Dataset (Default `'a'`).\n\n**`format`**: underlying file format to use (one of `'NETCDF4',\n'NETCDF4_CLASSIC', 'NETCDF3_CLASSIC'`, `'NETCDF3_64BIT_OFFSET'` or\n`'NETCDF3_64BIT_DATA'`. Default `'NETCDF4'`.\n\nDataset instance for `ncfilename` is returned.\n\n[ncgen]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#ncgen_guide\n[cdl]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#cdl_guide\n        ",
  "netCDF4._netCDF4.MFDataset.get_variables_by_attributes": "\n**`get_variables_by_attributes(self, **kwargs)`**\n\nReturns a list of variables that match specific conditions.\n\nCan pass in key=value parameters and variables are returned that\ncontain all of the matches. For example,\n\n```python\n>>> # Get variables with x-axis attribute.\n>>> vs = nc.get_variables_by_attributes(axis='X')\n>>> # Get variables with matching \"standard_name\" attribute\n>>> vs = nc.get_variables_by_attributes(standard_name='northward_sea_water_velocity')\n```\n\nCan pass in key=callable parameter and variables are returned if the\ncallable returns True.  The callable should accept a single parameter,\nthe attribute value.  None is given as the attribute value when the\nattribute does not exist on the variable. For example,\n\n```python\n>>> # Get Axis variables\n>>> vs = nc.get_variables_by_attributes(axis=lambda v: v in ['X', 'Y', 'Z', 'T'])\n>>> # Get variables that don't have an \"axis\" attribute\n>>> vs = nc.get_variables_by_attributes(axis=lambda v: v is None)\n>>> # Get variables that have a \"grid_mapping\" attribute\n>>> vs = nc.get_variables_by_attributes(grid_mapping=lambda v: v is not None)\n```\n",
  "netCDF4._netCDF4.MFDataset.getncattr": "\n**`getncattr(self,name)`**\n\nretrieve a netCDF dataset or group attribute.\nUse if you need to get a netCDF attribute with the same\nname as one of the reserved python attributes.\n\noption kwarg `encoding` can be used to specify the\ncharacter encoding of a string attribute (default is `utf-8`).",
  "netCDF4._netCDF4.MFDataset.has_blosc_filter": "**`has_blosc_filter(self)`**\n        returns True if blosc compression filter is available\n        ",
  "netCDF4._netCDF4.MFDataset.has_bzip2_filter": "**`has_bzip2_filter(self)`**\n        returns True if bzip2 compression filter is available\n        ",
  "netCDF4._netCDF4.MFDataset.has_szip_filter": "**`has_szip_filter(self)`**\n        returns True if szip compression filter is available\n        ",
  "netCDF4._netCDF4.MFDataset.has_zstd_filter": "**`has_zstd_filter(self)`**\n        returns True if zstd compression filter is available\n        ",
  "netCDF4._netCDF4.MFDataset.isopen": "\n        **`isopen(self)`**\n\n        True if all files are open, False otherwise.\n        ",
  "netCDF4._netCDF4.MFDataset.name": "string name of Group instance",
  "netCDF4._netCDF4.MFDataset.ncattrs": "\n        **`ncattrs(self)`**\n\n        return the netcdf attribute names from the master file.\n        ",
  "netCDF4._netCDF4.MFDataset.renameAttribute": "\n**`renameAttribute(self, oldname, newname)`**\n\nrename a `Dataset` or `Group` attribute named `oldname` to `newname`.",
  "netCDF4._netCDF4.MFDataset.renameDimension": "\n**`renameDimension(self, oldname, newname)`**\n\nrename a `Dimension` named `oldname` to `newname`.",
  "netCDF4._netCDF4.MFDataset.renameGroup": "\n**`renameGroup(self, oldname, newname)`**\n\nrename a `Group` named `oldname` to `newname` (requires netcdf >= 4.3.1).",
  "netCDF4._netCDF4.MFDataset.renameVariable": "\n**`renameVariable(self, oldname, newname)`**\n\nrename a `Variable` named `oldname` to `newname`",
  "netCDF4._netCDF4.MFDataset.set_always_mask": "\n**`set_always_mask(self, True_or_False)`**\n\nCall `Variable.set_always_mask` for all variables contained in\nthis `Dataset` or `Group`, as well as for all\nvariables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic conversion of\nmasked arrays with no missing values to regular numpy arrays shall be\napplied for all variables. Default True. Set to False to restore the default behaviour\nin versions prior to 1.4.1 (numpy array returned unless missing values are present,\notherwise masked array returned).\n\n***Note***: Calling this function only affects existing\nvariables. Variables created after calling this function will follow\nthe default behaviour.\n        ",
  "netCDF4._netCDF4.MFDataset.set_auto_chartostring": "\n**`set_auto_chartostring(self, True_or_False)`**\n\nCall `Variable.set_auto_chartostring` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic conversion of\nall character arrays <--> string arrays should be performed for\ncharacter variables (variables of type `NC_CHAR` or `S1`) with the\n`_Encoding` attribute set.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.MFDataset.set_auto_mask": "\n**`set_auto_mask(self, True_or_False)`**\n\nCall `Variable.set_auto_mask` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups. Only affects\nVariables with primitive or enum types (not compound or vlen Variables).\n\n**`True_or_False`**: Boolean determining if automatic conversion to masked arrays\nshall be applied for all variables.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.MFDataset.set_auto_maskandscale": "\n**`set_auto_maskandscale(self, True_or_False)`**\n\nCall `Variable.set_auto_maskandscale` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic conversion to masked arrays\nand variable scaling shall be applied for all variables.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.MFDataset.set_auto_scale": "\n**`set_auto_scale(self, True_or_False)`**\n\nCall `Variable.set_auto_scale` for all variables contained in this `Dataset` or\n`Group`, as well as for all variables in all its subgroups.\n\n**`True_or_False`**: Boolean determining if automatic variable scaling\nshall be applied for all variables.\n\n***Note***: Calling this function only affects existing variables. Variables created\nafter calling this function will follow the default behaviour.\n        ",
  "netCDF4._netCDF4.MFDataset.set_fill_off": "\n**`set_fill_off(self)`**\n\nSets the fill mode for a `Dataset` open for writing to `off`.\n\nThis will prevent the data from being pre-filled with fill values, which\nmay result in some performance improvements. However, you must then make\nsure the data is actually written before being read.",
  "netCDF4._netCDF4.MFDataset.set_fill_on": "\n**`set_fill_on(self)`**\n\nSets the fill mode for a `Dataset` open for writing to `on`.\n\nThis causes data to be pre-filled with fill values. The fill values can be\ncontrolled by the variable's `_Fill_Value` attribute, but is usually\nsufficient to the use the netCDF default `_Fill_Value` (defined\nseparately for each variable type). The default behavior of the netCDF\nlibrary corresponds to `set_fill_on`.  Data which are equal to the\n`_Fill_Value` indicate that the variable was created, but never written\nto.",
  "netCDF4._netCDF4.MFDataset.set_ncstring_attrs": "\n**`set_ncstring_attrs(self, True_or_False)`**\n\nCall `Variable.set_ncstring_attrs` for all variables contained in\nthis `Dataset` or `Group`, as well as for all its\nsubgroups and their variables.\n\n**`True_or_False`**: Boolean determining if all string attributes are\ncreated as variable-length NC_STRINGs, (if True), or if ascii text\nattributes are stored as NC_CHARs (if False; default)\n\n***Note***: Calling this function only affects newly created attributes\nof existing (sub-) groups and their variables.\n        ",
  "netCDF4._netCDF4.MFDataset.setncattr": "\n**`setncattr(self,name,value)`**\n\nset a netCDF dataset or group attribute using name,value pair.\nUse if you need to set a netCDF attribute with the\nwith the same name as one of the reserved python attributes.",
  "netCDF4._netCDF4.MFDataset.setncattr_string": "\n**`setncattr_string(self,name,value)`**\n\nset a netCDF dataset or group string attribute using name,value pair.\nUse if you need to ensure that a netCDF attribute is created with type\n`NC_STRING` if the file format is `NETCDF4`.",
  "netCDF4._netCDF4.MFDataset.setncatts": "\n**`setncatts(self,attdict)`**\n\nset a bunch of netCDF dataset or group attributes at once using a python dictionary.\nThis may be faster when setting a lot of attributes for a `NETCDF3`\nformatted file, since nc_redef/nc_enddef is not called in between setting\neach attribute",
  "netCDF4._netCDF4.MFDataset.sync": "\n**`sync(self)`**\n\nWrites all buffered data in the `Dataset` to the disk file.",
  "netCDF4._netCDF4.MFDataset.tocdl": "\n**`tocdl(self, coordvars=False, data=False, outfile=None)`**\n\ncall [ncdump][ncdump] via subprocess to create [CDL][cdl]\ntext representation of Dataset. Requires [ncdump][ncdump]\nto be installed and in `$PATH`.\n\n**`coordvars`**: include coordinate variable data (via `ncdump -c`). Default False\n\n**`data`**: if True, write out variable data (Default False).\n\n**`outfile`**: If not None, file to output ncdump to. Default is to return a string.\n\n[ncdump]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#ncdump_guide\n[cdl]: https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_utilities_guide.html#cdl_guide\n        ",
  "netCDF4._netCDF4.MFTime": "\nClass providing an interface to a MFDataset time Variable by imposing a unique common\ntime unit and/or calendar to all files.\n\nExample usage (See `MFTime.__init__` for more details):\n\n```python\n>>> import numpy as np\n>>> f1 = Dataset(\"mftest_1.nc\",\"w\", format=\"NETCDF4_CLASSIC\")\n>>> f2 = Dataset(\"mftest_2.nc\",\"w\", format=\"NETCDF4_CLASSIC\")\n>>> f1.createDimension(\"time\",None)\n>>> f2.createDimension(\"time\",None)\n>>> t1 = f1.createVariable(\"time\",\"i\",(\"time\",))\n>>> t2 = f2.createVariable(\"time\",\"i\",(\"time\",))\n>>> t1.units = \"days since 2000-01-01\"\n>>> t2.units = \"days since 2000-02-01\"\n>>> t1.calendar = \"standard\"\n>>> t2.calendar = \"standard\"\n>>> t1[:] = np.arange(31)\n>>> t2[:] = np.arange(30)\n>>> f1.close()\n>>> f2.close()\n>>> # Read the two files in at once, in one Dataset.\n>>> f = MFDataset(\"mftest_*nc\")\n>>> t = f.variables[\"time\"]\n>>> print(t.units)\ndays since 2000-01-01\n>>> print(t[32])  # The value written in the file, inconsistent with the MF time units.\n1\n>>> T = MFTime(t)\n>>> print(T[32])\n32\n```\n    ",
  "netCDF4._netCDF4.MFTime.__init__": "\n        **`__init__(self, time, units=None, calendar=None)`**\n\n        Create a time Variable with units consistent across a multifile\n        dataset.\n\n        **`time`**: Time variable from a `MFDataset`.\n\n        **`units`**: Time units, for example, `'days since 1979-01-01'`. If `None`,\n        use the units from the master variable.\n\n        **`calendar`**: Calendar overload to use across all files, for example,\n        `'standard'` or `'gregorian'`. If `None`, check that the calendar attribute\n        is present on each variable and values are unique across files raising a\n        `ValueError` otherwise.\n        ",
  "netCDF4._netCDF4.MFTime.__weakref__": "list of weak references to the object (if defined)",
  "netCDF4._netCDF4.NetCDF4MissingFeatureException": "Custom exception when trying to use features missing from the linked netCDF library",
  "netCDF4._netCDF4.NetCDF4MissingFeatureException.__weakref__": "list of weak references to the object (if defined)",
  "netCDF4._netCDF4.VLType": "\nA `VLType` instance is used to describe a variable length (VLEN) data\ntype, and can be passed to the the `Dataset.createVariable` method of\na `Dataset` or `Group` instance. See\n`VLType.__init__` for more details.\n\nThe instance variables `dtype` and `name` should not be modified by\nthe user.\n    ",
  "netCDF4._netCDF4.VLType.__init__": "\n        **`__init__(group, datatype, datatype_name)`**\n\n        VLType constructor.\n\n        **`group`**: `Group` instance to associate with the VLEN datatype.\n\n        **`datatype`**: An numpy dtype object describing the component type for the\n        variable length array.\n\n        **`datatype_name`**: a Python string containing a description of the\n        VLEN data type.\n\n        ***`Note`***: `VLType` instances should be created using the\n        `Dataset.createVLType` method of a `Dataset` or\n        `Group` instance, not using this class directly.\n        ",
  "netCDF4._netCDF4.VLType.__str__": "Return str(self).",
  "netCDF4._netCDF4.Variable": "\nA netCDF `Variable` is used to read and write netCDF data.  They are\nanalogous to numpy array objects. See `Variable.__init__` for more\ndetails.\n\nA list of attribute names corresponding to netCDF attributes defined for\nthe variable can be obtained with the `Variable.ncattrs` method. These\nattributes can be created by assigning to an attribute of the\n`Variable` instance. A dictionary containing all the netCDF attribute\nname/value pairs is provided by the `__dict__` attribute of a\n`Variable` instance.\n\nThe following class variables are read-only:\n\n**`dimensions`**: A tuple containing the names of the\ndimensions associated with this variable.\n\n**`dtype`**: A numpy dtype object describing the\nvariable's data type.\n\n**`ndim`**: The number of variable dimensions.\n\n**`shape`**: A tuple with the current shape (length of all dimensions).\n\n**`scale`**: If True, `scale_factor` and `add_offset` are\napplied, and signed integer data is automatically converted to\nunsigned integer data if the `_Unsigned` attribute is set to \"true\" or \"True\".\nDefault is `True`, can be reset using `Variable.set_auto_scale` and\n`Variable.set_auto_maskandscale` methods.\n\n**`mask`**: If True, data is automatically converted to/from masked\narrays when missing values or fill values are present. Default is `True`, can be\nreset using `Variable.set_auto_mask` and `Variable.set_auto_maskandscale`\nmethods. Only relevant for Variables with primitive or enum types (ignored\nfor compound and vlen Variables).\n\n**`chartostring`**: If True, data is automatically converted to/from character\narrays to string arrays when the `_Encoding` variable attribute is set.\nDefault is `True`, can be reset using\n`Variable.set_auto_chartostring` method.\n\n**`least_significant_digit`**: Describes the power of ten of the\nsmallest decimal place in the data the contains a reliable value.  Data is\ntruncated to this decimal place when it is assigned to the `Variable`\ninstance. If `None`, the data is not truncated.\n\n**`significant_digits`**: New in version 1.6.0. Describes the number of significant\ndigits in the data the contains a reliable value.  Data is\ntruncated to retain this number of significant digits when it is assigned to the\n`Variable` instance. If `None`, the data is not truncated.\nOnly available with netcdf-c >= 4.9.0,\nand only works with `NETCDF4` or `NETCDF4_CLASSIC` formatted files.\nThe number of significant digits used in the quantization of variable data can be\nobtained using the `Variable.significant_digits` method. Default `None` -\nno quantization done.\n\n**`quantize_mode`**: New in version 1.6.0. Controls\nthe quantization algorithm (default 'BitGroom', 'BitRound' and\n'GranularBitRound' also available).  The 'GranularBitRound'\nalgorithm may result in better compression for typical geophysical datasets.\nIgnored if `significant_digits` not specified. If 'BitRound' is used, then\n`significant_digits` is interpreted as binary (not decimal) digits.\n\n**`__orthogonal_indexing__`**: Always `True`.  Indicates to client code\nthat the object supports 'orthogonal indexing', which means that slices\nthat are 1d arrays or lists slice along each dimension independently.  This\nbehavior is similar to Fortran or Matlab, but different than numpy.\n\n**`datatype`**: numpy data type (for primitive data types) or VLType/CompoundType\n instance (for compound or vlen data types).\n\n**`name`**: String name.\n\n**`size`**: The number of stored elements.\n    ",
  "netCDF4._netCDF4.Variable.__delattr__": "Implement delattr(self, name).",
  "netCDF4._netCDF4.Variable.__delitem__": "Delete self[key].",
  "netCDF4._netCDF4.Variable.__getattribute__": "Return getattr(self, name).",
  "netCDF4._netCDF4.Variable.__getitem__": "Return self[key].",
  "netCDF4._netCDF4.Variable.__init__": "\n        **`__init__(self, group, name, datatype, dimensions=(), compression=None, zlib=False,\n        complevel=4, shuffle=True, szip_coding='nn', szip_pixels_per_block=8,\n        blosc_shuffle=1, fletcher32=False, contiguous=False,\n        chunksizes=None, endian='native',\n        least_significant_digit=None,fill_value=None,chunk_cache=None)`**\n\n        `Variable` constructor.\n\n        **`group`**: `Group` or `Dataset` instance to associate with variable.\n\n        **`name`**: Name of the variable.\n\n        **`datatype`**: `Variable` data type. Can be specified by providing a\n        numpy dtype object, or a string that describes a numpy dtype object.\n        Supported values, corresponding to `str` attribute of numpy dtype\n        objects, include `'f4'` (32-bit floating point), `'f8'` (64-bit floating\n        point), `'i4'` (32-bit signed integer), `'i2'` (16-bit signed integer),\n        `'i8'` (64-bit signed integer), `'i4'` (8-bit signed integer), `'i1'`\n        (8-bit signed integer), `'u1'` (8-bit unsigned integer), `'u2'` (16-bit\n        unsigned integer), `'u4'` (32-bit unsigned integer), `'u8'` (64-bit\n        unsigned integer), or `'S1'` (single-character string).  From\n        compatibility with Scientific.IO.NetCDF, the old Numeric single character\n        typecodes can also be used (`'f'` instead of `'f4'`, `'d'` instead of\n        `'f8'`, `'h'` or `'s'` instead of `'i2'`, `'b'` or `'B'` instead of\n        `'i1'`, `'c'` instead of `'S1'`, and `'i'` or `'l'` instead of\n        `'i4'`). `datatype` can also be a `CompoundType` instance\n        (for a structured, or compound array), a `VLType` instance\n        (for a variable-length array), or the python `str` builtin\n        (for a variable-length string array). Numpy string and unicode datatypes with\n        length greater than one are aliases for `str`.\n\n        **`dimensions`**: a tuple containing the variable's Dimension instances\n        (defined previously with `createDimension`). Default is an empty tuple\n        which means the variable is a scalar (and therefore has no dimensions).\n\n        **`compression`**: compression algorithm to use.\n        Currently `zlib`,`szip`,`zstd`,`bzip2`,`blosc_lz`,`blosc_lz4`,`blosc_lz4hc`,\n        `blosc_zlib` and `blosc_zstd` are supported.\n        Default is `None` (no compression).  All of the compressors except\n        `zlib` and `szip` use the HDF5 plugin architecture.\n\n        **`zlib`**: if `True`, data assigned to the `Variable`\n        instance is compressed on disk. Default `False`. Deprecated - use\n        `compression='zlib'` instead.\n\n        **`complevel`**: the level of compression to use (1 is the fastest,\n        but poorest compression, 9 is the slowest but best compression). Default 4.\n        Ignored if `compression=None` or `szip`. A value of 0 disables compression.\n\n        **`shuffle`**: if `True`, the HDF5 shuffle filter is applied\n        to improve zlib compression. Default `True`. Ignored unless `compression = 'zlib'`.\n\n        **`blosc_shuffle`**: shuffle filter inside blosc compressor (only\n        relevant if compression kwarg set to one of the blosc compressors).\n        Can be 0 (no blosc shuffle), 1 (bytewise shuffle) or 2 (bitwise\n        shuffle)). Default is 1. Ignored if blosc compressor not used.\n\n        **`szip_coding`**: szip coding method. Can be `ec` (entropy coding)\n        or `nn` (nearest neighbor coding). Default is `nn`.\n        Ignored if szip compressor not used.\n\n        **`szip_pixels_per_block`**: Can be 4,8,16 or 32 (Default 8).\n        Ignored if szip compressor not used.\n\n        **`fletcher32`**: if `True` (default `False`), the Fletcher32 checksum\n        algorithm is used for error detection.\n\n        **`contiguous`**: if `True` (default `False`), the variable data is\n        stored contiguously on disk.  Default `False`. Setting to `True` for\n        a variable with an unlimited dimension will trigger an error. Fixed\n        size variables (with no unlimited dimension) with no compression\n        filters are contiguous by default.\n\n        **`chunksizes`**: Can be used to specify the HDF5 chunksizes for each\n        dimension of the variable. A detailed discussion of HDF chunking and I/O\n        performance is available\n        [here](https://support.hdfgroup.org/HDF5/doc/Advanced/Chunking).\n        The default chunking scheme in the netcdf-c library is discussed\n        [here](https://www.unidata.ucar.edu/software/netcdf/documentation/NUG/netcdf_perf_chunking.html).\n        Basically, you want the chunk size for each dimension to match as\n        closely as possible the size of the data block that users will read\n        from the file. `chunksizes` cannot be set if `contiguous=True`.\n\n        **`endian`**: Can be used to control whether the\n        data is stored in little or big endian format on disk. Possible\n        values are `little, big` or `native` (default). The library\n        will automatically handle endian conversions when the data is read,\n        but if the data is always going to be read on a computer with the\n        opposite format as the one used to create the file, there may be\n        some performance advantage to be gained by setting the endian-ness.\n        For netCDF 3 files (that don't use HDF5), only `endian='native'` is allowed.\n\n        The `compression, zlib, complevel, shuffle, fletcher32, contiguous` and `chunksizes`\n        keywords are silently ignored for netCDF 3 files that do not use HDF5.\n\n        **`least_significant_digit`**: If this or `significant_digits` are specified,\n        variable data will be truncated (quantized).\n        In conjunction with `compression='zlib'` this produces\n        'lossy', but significantly more efficient compression. For example, if\n        `least_significant_digit=1`, data will be quantized using\n        around(scale*data)/scale, where scale = 2**bits, and bits is determined\n        so that a precision of 0.1 is retained (in this case bits=4). Default is\n        `None`, or no quantization.\n\n        **`significant_digits`**: New in version 1.6.0.\n        As described for `least_significant_digit`\n        except the number of significant digits retained is prescribed independent\n        of the floating point exponent. Default `None` - no quantization done.\n\n        **`quantize_mode`**: New in version 1.6.0. Controls\n        the quantization algorithm (default 'BitGroom', 'BitRound' and\n        'GranularBitRound' also available).  The 'GranularBitRound'\n        algorithm may result in better compression for typical geophysical datasets.\n        Ignored if `significant_digts` not specified. If 'BitRound' is used, then\n        `significant_digits` is interpreted as binary (not decimal) digits.\n\n        **`fill_value`**:  If specified, the default netCDF `_FillValue` (the\n        value that the variable gets filled with before any data is written to it)\n        is replaced with this value.  If fill_value is set to `False`, then\n        the variable is not pre-filled. The default netCDF fill values can be found\n        in the dictionary `netCDF4.default_fillvals`.\n\n        **`chunk_cache`**: If specified, sets the chunk cache size for this variable.\n        Persists as long as Dataset is open. Use `set_var_chunk_cache` to\n        change it when Dataset is re-opened.\n\n        ***Note***: `Variable` instances should be created using the\n        `Dataset.createVariable` method of a `Dataset` or\n        `Group` instance, not using this class directly.\n        ",
  "netCDF4._netCDF4.Variable.__len__": "Return len(self).",
  "netCDF4._netCDF4.Variable.__setattr__": "Implement setattr(self, name, value).",
  "netCDF4._netCDF4.Variable.__setitem__": "Set self[key] to value.",
  "netCDF4._netCDF4.Variable.__str__": "Return str(self).",
  "netCDF4._netCDF4.Variable._assign_vlen": "private method to assign data to a single item in a VLEN variable",
  "netCDF4._netCDF4.Variable._get": "Private method to retrieve data from a netCDF variable",
  "netCDF4._netCDF4.Variable._put": "Private method to put data into a netCDF variable",
  "netCDF4._netCDF4.Variable.assignValue": "\n**`assignValue(self, val)`**\n\nassign a value to a scalar variable.  Provided for compatibility with\nScientific.IO.NetCDF, can also be done by assigning to an Ellipsis slice ([...]).",
  "netCDF4._netCDF4.Variable.chunking": "\n**`chunking(self)`**\n\nreturn variable chunking information.  If the dataset is\ndefined to be contiguous (and hence there is no chunking) the word 'contiguous'\nis returned.  Otherwise, a sequence with the chunksize for\neach dimension is returned.",
  "netCDF4._netCDF4.Variable.datatype": "numpy data type (for primitive data types) or\n        VLType/CompoundType/EnumType instance\n        (for compound, vlen  or enum data types)",
  "netCDF4._netCDF4.Variable.delncattr": "\n**`delncattr(self,name,value)`**\n\ndelete a netCDF variable attribute.  Use if you need to delete a\nnetCDF attribute with the same name as one of the reserved python\nattributes.",
  "netCDF4._netCDF4.Variable.dimensions": "get variables's dimension names",
  "netCDF4._netCDF4.Variable.endian": "\n**`endian(self)`**\n\nreturn endian-ness (`little,big,native`) of variable (as stored in HDF5 file).",
  "netCDF4._netCDF4.Variable.filters": "\n**`filters(self)`**\n\nreturn dictionary containing HDF5 filter parameters.",
  "netCDF4._netCDF4.Variable.getValue": "\n**`getValue(self)`**\n\nget the value of a scalar variable.  Provided for compatibility with\nScientific.IO.NetCDF, can also be done by slicing with an Ellipsis ([...]).",
  "netCDF4._netCDF4.Variable.get_dims": "\n**`get_dims(self)`**\n\nreturn a tuple of `Dimension` instances associated with this\n`Variable`.\n        ",
  "netCDF4._netCDF4.Variable.get_var_chunk_cache": "\n**`get_var_chunk_cache(self)`**\n\nreturn variable chunk cache information in a tuple (size,nelems,preemption).\nSee netcdf C library documentation for `nc_get_var_chunk_cache` for\ndetails.",
  "netCDF4._netCDF4.Variable.getncattr": "\n**`getncattr(self,name)`**\n\nretrieve a netCDF variable attribute.  Use if you need to set a\nnetCDF attribute with the same name as one of the reserved python\nattributes.\n\noption kwarg `encoding` can be used to specify the\ncharacter encoding of a string attribute (default is `utf-8`).",
  "netCDF4._netCDF4.Variable.group": "\n**`group(self)`**\n\nreturn the group that this `Variable` is a member of.",
  "netCDF4._netCDF4.Variable.name": "string name of Variable instance",
  "netCDF4._netCDF4.Variable.ncattrs": "\n**`ncattrs(self)`**\n\nreturn netCDF attribute names for this `Variable` in a list.",
  "netCDF4._netCDF4.Variable.quantization": "\n**`quantization(self)`**\n\nreturn number of significant digits and the algorithm used in quantization.\nReturns None if quantization not active.\n",
  "netCDF4._netCDF4.Variable.renameAttribute": "\n**`renameAttribute(self, oldname, newname)`**\n\nrename a `Variable` attribute named `oldname` to `newname`.",
  "netCDF4._netCDF4.Variable.set_always_mask": "\n**`set_always_mask(self,always_mask)`**\n\nturn on or off conversion of data without missing values to regular\nnumpy arrays.\n\n`always_mask` is a Boolean determining if automatic conversion of\nmasked arrays with no missing values to regular numpy arrays shall be\napplied. Default is True. Set to False to restore the default behaviour\nin versions prior to 1.4.1 (numpy array returned unless missing values are present,\notherwise masked array returned).\n        ",
  "netCDF4._netCDF4.Variable.set_auto_chartostring": "\n**`set_auto_chartostring(self,chartostring)`**\n\nturn on or off automatic conversion of character variable data to and\nfrom numpy fixed length string arrays when the `_Encoding` variable attribute\nis set.\n\nIf `chartostring` is set to `True`, when data is read from a character variable\n(dtype = `S1`) that has an `_Encoding` attribute, it is converted to a numpy\nfixed length unicode string array (dtype = `UN`, where `N` is the length\nof the the rightmost dimension of the variable).  The value of `_Encoding`\nis the unicode encoding that is used to decode the bytes into strings.\n\nWhen numpy string data is written to a variable it is converted back to\nindiviual bytes, with the number of bytes in each string equalling the\nrightmost dimension of the variable.\n\nThe default value of `chartostring` is `True`\n(automatic conversions are performed).\n        ",
  "netCDF4._netCDF4.Variable.set_auto_mask": "\n**`set_auto_mask(self,mask)`**\n\nturn on or off automatic conversion of variable data to and\nfrom masked arrays .\n\nIf `mask` is set to `True`, when data is read from a variable\nit is converted to a masked array if any of the values are exactly\nequal to the either the netCDF _FillValue or the value specified by the\nmissing_value variable attribute. The fill_value of the masked array\nis set to the missing_value attribute (if it exists), otherwise\nthe netCDF _FillValue attribute (which has a default value\nfor each data type). If the variable has no missing_value attribute, the\n_FillValue is used instead. If the variable has valid_min/valid_max and\nmissing_value attributes, data outside the specified range will be masked.\nWhen data is written to a variable, the masked\narray is converted back to a regular numpy array by replacing all the\nmasked values by the missing_value attribute of the variable (if it\nexists).  If the variable has no missing_value attribute, the _FillValue\nis used instead.\n\nThe default value of `mask` is `True`\n(automatic conversions are performed).\n        ",
  "netCDF4._netCDF4.Variable.set_auto_maskandscale": "\n**`set_auto_maskandscale(self,maskandscale)`**\n\nturn on or off automatic conversion of variable data to and\nfrom masked arrays, automatic packing/unpacking of variable\ndata using `scale_factor` and `add_offset` attributes and\nautomatic conversion of signed integer data to unsigned integer\ndata if the `_Unsigned` attribute exists and is set to \"true\" (or \"True\").\n\nIf `maskandscale` is set to `True`, when data is read from a variable\nit is converted to a masked array if any of the values are exactly\nequal to the either the netCDF _FillValue or the value specified by the\nmissing_value variable attribute. The fill_value of the masked array\nis set to the missing_value attribute (if it exists), otherwise\nthe netCDF _FillValue attribute (which has a default value\nfor each data type). If the variable has no missing_value attribute, the\n_FillValue is used instead. If the variable has valid_min/valid_max and\nmissing_value attributes, data outside the specified range will be masked.\nWhen data is written to a variable, the masked\narray is converted back to a regular numpy array by replacing all the\nmasked values by the missing_value attribute of the variable (if it\nexists).  If the variable has no missing_value attribute, the _FillValue\nis used instead.\n\nIf `maskandscale` is set to `True`, and the variable has a\n`scale_factor` or an `add_offset` attribute, then data read\nfrom that variable is unpacked using::\n\n    data = self.scale_factor*data + self.add_offset\n\nWhen data is written to a variable it is packed using::\n\n    data = (data - self.add_offset)/self.scale_factor\n\nIf either scale_factor is present, but add_offset is missing, add_offset\nis assumed zero.  If add_offset is present, but scale_factor is missing,\nscale_factor is assumed to be one.\nFor more information on how `scale_factor` and `add_offset` can be\nused to provide simple compression, see the\n[PSL metadata conventions](http://www.esrl.noaa.gov/psl/data/gridded/conventions/cdc_netcdf_standard.shtml).\n\nIn addition, if `maskandscale` is set to `True`, and if the variable has an\nattribute `_Unsigned` set to \"true\", and the variable has a signed integer data type,\na view to the data is returned with the corresponding unsigned integer data type.\nThis convention is used by the netcdf-java library to save unsigned integer\ndata in `NETCDF3` or `NETCDF4_CLASSIC` files (since the `NETCDF3`\ndata model does not have unsigned integer data types).\n\nThe default value of `maskandscale` is `True`\n(automatic conversions are performed).\n        ",
  "netCDF4._netCDF4.Variable.set_auto_scale": "\n**`set_auto_scale(self,scale)`**\n\nturn on or off automatic packing/unpacking of variable\ndata using `scale_factor` and `add_offset` attributes.\nAlso turns on and off automatic conversion of signed integer data\nto unsigned integer data if the variable has an `_Unsigned`\nattribute set to \"true\" or \"True\".\n\nIf `scale` is set to `True`, and the variable has a\n`scale_factor` or an `add_offset` attribute, then data read\nfrom that variable is unpacked using::\n\n    data = self.scale_factor*data + self.add_offset\n\nWhen data is written to a variable it is packed using::\n\n    data = (data - self.add_offset)/self.scale_factor\n\nIf either scale_factor is present, but add_offset is missing, add_offset\nis assumed zero.  If add_offset is present, but scale_factor is missing,\nscale_factor is assumed to be one.\nFor more information on how `scale_factor` and `add_offset` can be\nused to provide simple compression, see the\n[PSL metadata conventions](http://www.esrl.noaa.gov/psl/data/gridded/conventions/cdc_netcdf_standard.shtml).\n\nIn addition, if `scale` is set to `True`, and if the variable has an\nattribute `_Unsigned` set to \"true\", and the variable has a signed integer data type,\na view to the data is returned with the corresponding unsigned integer datatype.\nThis convention is used by the netcdf-java library to save unsigned integer\ndata in `NETCDF3` or `NETCDF4_CLASSIC` files (since the `NETCDF3`\ndata model does not have unsigned integer data types).\n\nThe default value of `scale` is `True`\n(automatic conversions are performed).\n        ",
  "netCDF4._netCDF4.Variable.set_collective": "**`set_collective(self,True_or_False)`**\n\n        turn on or off collective parallel IO access. Ignored if file is not\n        open for parallel access.\n        ",
  "netCDF4._netCDF4.Variable.set_ncstring_attrs": "\n**`set_always_mask(self,ncstring_attrs)`**\n\nturn on or off creating NC_STRING string attributes.\n\nIf `ncstring_attrs` is set to `True` then text attributes will be variable-length\nNC_STRINGs.\n\nThe default value of `ncstring_attrs` is `False` (writing ascii text attributes as\nNC_CHAR).\n\n        ",
  "netCDF4._netCDF4.Variable.set_var_chunk_cache": "\n**`set_var_chunk_cache(self,size=None,nelems=None,preemption=None)`**\n\nchange variable chunk cache settings.\nSee netcdf C library documentation for `nc_set_var_chunk_cache` for\ndetails.",
  "netCDF4._netCDF4.Variable.setncattr": "\n**`setncattr(self,name,value)`**\n\nset a netCDF variable attribute using name,value pair.  Use if you need to set a\nnetCDF attribute with the same name as one of the reserved python\nattributes.",
  "netCDF4._netCDF4.Variable.setncattr_string": "\n**`setncattr_string(self,name,value)`**\n\nset a netCDF variable string attribute using name,value pair.\nUse if you need to ensure that a netCDF attribute is created with type\n`NC_STRING` if the file format is `NETCDF4`.\nUse if you need to set an attribute to an array of variable-length strings.",
  "netCDF4._netCDF4.Variable.setncatts": "\n**`setncatts(self,attdict)`**\n\nset a bunch of netCDF variable attributes at once using a python dictionary.\nThis may be faster when setting a lot of attributes for a `NETCDF3`\nformatted file, since nc_redef/nc_enddef is not called in between setting\neach attribute",
  "netCDF4._netCDF4.Variable.shape": "find current sizes of all variable dimensions",
  "netCDF4._netCDF4.Variable.size": "Return the number of stored elements.",
  "netCDF4._netCDF4.Variable.use_nc_get_vars": "\n**`use_nc_get_vars(self,_use_get_vars)`**\n\nenable the use of netcdf library routine `nc_get_vars`\nto retrieve strided variable slices.  By default,\n`nc_get_vars` may not used by default (depending on the\nversion of the netcdf-c library being used) since it may be\nslower than multiple calls to the unstrided read routine `nc_get_vara`.\n        ",
  "netCDF4._netCDF4._Dimension.__weakref__": "list of weak references to the object (if defined)",
  "netCDF4._netCDF4._Variable.__getitem__": "Get records from a concatenated set of variables.",
  "netCDF4._netCDF4._Variable.__weakref__": "list of weak references to the object (if defined)",
  "netCDF4._netCDF4.chartostring": "\n**`chartostring(b,encoding='utf-8')`**\n\nconvert a character array to a string array with one less dimension.\n\n**`b`**:  Input character array (numpy datatype `'S1'` or `'U1'`).\nWill be converted to a array of strings, where each string has a fixed\nlength of `b.shape[-1]` characters.\n\noptional kwarg `encoding` can be used to specify character encoding (default\n`utf-8`). If `encoding` is 'none' or 'bytes', a `numpy.string_` btye array is\nreturned.\n\nreturns a numpy string array with datatype `'UN'` (or `'SN'`) and shape\n`b.shape[:-1]` where where `N=b.shape[-1]`.",
  "netCDF4._netCDF4.dtype_is_complex": "Return True if dtype is a complex number",
  "netCDF4._netCDF4.get_alignment": "**`get_alignment()`**\n\n    return current netCDF alignment within HDF5 files in a tuple\n    (threshold,alignment). See netcdf C library documentation for\n    `nc_get_alignment` for details. Values can be reset with\n    `set_alignment`.\n\n    This function was added in netcdf 4.9.0.",
  "netCDF4._netCDF4.get_chunk_cache": "\n**`get_chunk_cache()`**\n\nreturn current netCDF chunk cache information in a tuple (size,nelems,preemption).\nSee netcdf C library documentation for `nc_get_chunk_cache` for\ndetails. Values can be reset with `set_chunk_cache`.",
  "netCDF4._netCDF4.getlibversion": "\n**`getlibversion()`**\n\nreturns a string describing the version of the netcdf library\nused to build the module, and when it was built.\n    ",
  "netCDF4._netCDF4.set_alignment": "**`set_alignment(threshold,alignment)`**\n\n    Change the HDF5 file alignment.\n    See netcdf C library documentation for `nc_set_alignment` for\n    details.\n\n    This function was added in netcdf 4.9.0.",
  "netCDF4._netCDF4.set_chunk_cache": "\n**`set_chunk_cache(self,size=None,nelems=None,preemption=None)`**\n\nchange netCDF4 chunk cache settings.\nSee netcdf C library documentation for `nc_set_chunk_cache` for\ndetails.",
  "netCDF4._netCDF4.stringtoarr": "\n**`stringtoarr(a, NUMCHARS,dtype='S')`**\n\nconvert a string to a character array of length `NUMCHARS`\n\n**`a`**:  Input python string.\n\n**`NUMCHARS`**:  number of characters used to represent string\n(if len(a) < `NUMCHARS`, it will be padded on the right with blanks).\n\n**`dtype`**:  type of numpy array to return.  Default is `'S'`, which\nmeans an array of dtype `'S1'` will be returned.  If dtype=`'U'`, a\nunicode array (dtype = `'U1'`) will be returned.\n\nreturns a rank 1 numpy character array of length NUMCHARS with datatype `'S1'`\n(default) or `'U1'` (if dtype=`'U'`)",
  "netCDF4._netCDF4.stringtochar": "\n**`stringtochar(a,encoding='utf-8')`**\n\nconvert a string array to a character array with one extra dimension\n\n**`a`**:  Input numpy string array with numpy datatype `'SN'` or `'UN'`, where N\nis the number of characters in each string.  Will be converted to\nan array of characters (datatype `'S1'` or `'U1'`) of shape `a.shape + (N,)`.\n\noptional kwarg `encoding` can be used to specify character encoding (default\n`utf-8`). If `encoding` is 'none' or 'bytes', a `numpy.string_` the input array\nis treated a raw byte strings (`numpy.string_`).\n\nreturns a numpy character array with datatype `'S1'` or `'U1'`\nand shape `a.shape + (N,)`, where N is the length of each string in a."
}